<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mysql-Code with Mosh 笔记</title>
    <link href="/2021/08/26/Mysql%20with%20Mosh/"/>
    <url>/2021/08/26/Mysql%20with%20Mosh/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>brew安装Mysql</strong></p><div class="code-wrapper"><pre><code class="hljs no">lihan@LideMacBook-Air ~ % brew install mysql==&gt; Installing mysql==&gt; Summary🍺  /opt/homebrew/Cellar/mysql/8.0.26: 303 files, 296.7MB==&gt; mysqlWe&#x27;ve installed your MySQL database without a root password. To secure it run:    mysql_secure_installationMySQL is configured to only allow connections from localhost by defaultTo connect run:    mysql -urootTo have launchd start mysql now and restart at login:  brew services start mysqlOr, if you don&#x27;t want/need a background service you can just run:  mysql.server startlihan@LideMacBook-Air ~ % mysql.server startStarting MySQL.. SUCCESS! lihan@LideMacBook-Air ~ % mysql_secure_installationSecuring the MySQL server deployment.Connecting to MySQL using a blank password.VALIDATE PASSWORD COMPONENT can be used to test passwordsand improve security. It checks the strength of passwordand allows the users to set only those passwords which aresecure enough. Would you like to setup VALIDATE PASSWORD component?Press y|Y for Yes, any other key for No: yThere are three levels of password validation policy:LOW    Length &gt;= 8MEDIUM Length &gt;= 8, numeric, mixed case, and special charactersSTRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary                  filePlease enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 2Please set the password for root here.New password: Re-enter new password: Estimated strength of the password: 100 Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : yBy default, a MySQL installation has an anonymous user,allowing anyone to log into MySQL without having to havea user account created for them. This is intended only fortesting, and to make the installation go a bit smoother.You should remove them before moving into a productionenvironment.Remove anonymous users? (Press y|Y for Yes, any other key for No) : ySuccess.Normally, root should only be allowed to connect from&#x27;localhost&#x27;. This ensures that someone cannot guess atthe root password from the network.Disallow root login remotely? (Press y|Y for Yes, any other key for No)  n     ... skipping.By default, MySQL comes with a database named &#x27;test&#x27; thatanyone can access. This is also intended only for testing,and should be removed before moving into a productionenvironment.Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y - Dropping test database...Success. - Removing privileges on test database...Success.Reloading the privilege tables will ensure that all changesmade so far will take effect immediately.Reload privilege tables now? (Press y|Y for Yes, any other key for No) : ySuccess.All done! lihan@LideMacBook-Air ~ % mysql -u root -pEnter password: Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 11Server version: 8.0.26 HomebrewCopyright (c) 2000, 2021, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.mysql&gt; exit;Bye</code></pre></div><p><strong>建立数据库</strong></p><div class="code-wrapper"><pre><code class="hljs no">链接：https://pan.baidu.com/s/1xDsDWFLiRITYTT6HoFb7Tw 提取码：s5iz</code></pre></div><p>注意存放位置如果有中文路径可能会在之后报<code>error 2</code>错误</p><p>在<code>source</code>后直接拖入<code>sql</code>文件即可</p><div class="code-wrapper"><pre><code class="hljs no">mysql&gt; create database mydatabase;Query OK, 1 row affected (0.01 sec)mysql&gt; use mydatabaseDatabase changedmysql&gt; source /Users/lihan/Desktop/summer/create-databases.sql Query OK, 0 rows affected, 1 warning (0.00 sec)....mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mydatabase         || mysql              || performance_schema || sql_hr             || sql_inventory      || sql_invoicing      || sql_store          || sys                |+--------------------+9 rows in set (0.00 sec)mysql&gt; drop database mydatabase;Query OK, 0 rows affected (0.01 sec)</code></pre></div><h1 id="单表检索"><a href="#单表检索" class="headerlink" title="单表检索"></a>单表检索</h1><ul><li>Mysql大小写不分，建议大写关键字，小写其他内容</li><li>在行前使用<code>--</code>表示注释</li><li>每个语句后使用<code>;</code>表示结束</li><li>可以使用算术表达式</li><li>可以使用<code>AS</code>关键字为列取别名</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, point <span class="hljs-operator">*</span> <span class="hljs-number">10</span> <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">AS</span> `discount_factor`<span class="hljs-keyword">FROM</span> customers<span class="hljs-comment">-- WHERE custom_id = 1</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> first_name;</code></pre></div><ul><li><code>DISTINCT</code>可以删除重复项， <em>重复</em>是以列的组合判断的，<code>DISTINCT</code>必须放在开头</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> state <span class="hljs-keyword">FROM</span> customers;</code></pre></div><ul><li><code>WHERE</code>中对于文本需要使用单引号或双引号，文本大小写不敏感</li><li>注意此处的<code>Customers</code>与<code>va</code>均大小写不敏感</li><li><code>!=</code> ，<code>&lt;&gt;</code>均意为不等于</li><li>日期类型数据也需使用引号</li><li>可以使用<code>AND</code>，<code>OR</code>，<code>NOT</code>创建复合条件语句</li><li>条件语句中可以使用算数表达式</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> Customers<span class="hljs-keyword">WHERE</span> state <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;va&#x27;</span> <span class="hljs-keyword">AND</span> birth_data <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;1990-01-01&#x27;</span>;</code></pre></div><ul><li><code>IN</code>关键字判断是否在集合中</li><li><code>BETWEEN</code>关键字判断是否在闭区间内</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> customers<span class="hljs-keyword">WHERE</span> state <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;VA&#x27;</span>, <span class="hljs-string">&#x27;FL&#x27;</span>) <span class="hljs-keyword">AND</span> points <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">2000</span>;</code></pre></div><ul><li><code>LIKE</code>关键字用于文本模糊匹配常用的有：<code>_</code>单一字符，<code>%</code>任意数目字符</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> customers<span class="hljs-keyword">WHERE</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%field%&#x27;</span>;</code></pre></div><ul><li><code>REGEXP</code>关键字使用正则表达式进行模糊匹配</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> customers<span class="hljs-keyword">WHERE</span> last_name REGEXP <span class="hljs-string">&#x27;field&#x27;</span>;</code></pre></div><ul><li><code>NULL</code>表示空值</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> customers<span class="hljs-keyword">WHERE</span> phone <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;</code></pre></div><ul><li>结果集默认以主键为标准进行生序排序，使用<code>ORDER BY</code>关键字可以使用其他列为标准排序</li><li>默认升序排序，使用<code>DESC</code>进行降序排序</li><li>可以使用多个排序规则，越靠前优先级越高</li><li>Mysql中允许用于排序的列不是结果集的列</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name<span class="hljs-keyword">FROM</span> customers<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> state <span class="hljs-keyword">DESC</span>, first_name <span class="hljs-keyword">DESC</span>;</code></pre></div><ul><li><code>LIMIT</code>关键字用于限制结果集大小，可用于网站分页</li><li><code>LIMIT 3</code>代表结果集大小为3，<code>LIMIT 6, 3</code>代表跳过6行取3行</li><li>注意<code>WHERE</code>，<code>ORDER BY</code>，<code>LIMIT</code>在语句中出现的先后顺序</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> customers<span class="hljs-keyword">WHERE</span> state <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;va&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> points <span class="hljs-keyword">DESC</span>LIMIT <span class="hljs-number">3</span>;</code></pre></div><h1 id="多表检索"><a href="#多表检索" class="headerlink" title="多表检索"></a>多表检索</h1><ul><li><code>JOIN</code>默认代表内连接即 <code>INNER JOIN</code></li><li>可以为表取别名</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> o.customer_id<span class="hljs-keyword">FROM</span> orders o<span class="hljs-keyword">JOIN</span> customers <span class="hljs-keyword">ON</span> o.customer_id <span class="hljs-operator">=</span> customer.customer_id;</code></pre></div><ul><li>可以对不同数据库的表进行连接</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> order_items oi<span class="hljs-keyword">JOIN</span> sql_inventory.products p <span class="hljs-keyword">ON</span> oi.product_id <span class="hljs-operator">=</span> p.product_id;</code></pre></div><ul><li>表也可以与自身进行连接，称为自连接</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.employee_id, e.first_name, m.first_nam<span class="hljs-keyword">FROM</span> employees e<span class="hljs-keyword">JOIN</span> employees m <span class="hljs-keyword">WHERE</span> e.reports_to <span class="hljs-operator">=</span> m.employee_id;</code></pre></div><ul><li><code>JOIN</code>多次使用可以多表连接</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o<span class="hljs-keyword">JOIN</span> customers c<span class="hljs-keyword">ON</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id<span class="hljs-keyword">JOIN</span> order_statuses os<span class="hljs-keyword">ON</span> o.status <span class="hljs-operator">=</span> os.order_status_id;</code></pre></div><ul><li><code>AND</code>创建复合连接条件</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> order_items oi<span class="hljs-keyword">JOIN</span> order_items_notes oin<span class="hljs-keyword">ON</span> oi.order_id <span class="hljs-operator">=</span> oin.order_id<span class="hljs-keyword">AND</span> oi.product_id <span class="hljs-operator">=</span> oin.product_id;</code></pre></div><ul><li>一般我们使用显式连接（第一句）而不是隐式连接（第二句）</li><li>显式连接不加<code>ON</code>指名连接条件或隐式连接不加<code>WHERE</code>，的时候称为交叉连接，返回笛卡尔积的结果</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o<span class="hljs-keyword">JOIN</span> customers c<span class="hljs-keyword">ON</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o, customers c<span class="hljs-keyword">WHERE</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o, customers c;</code></pre></div><ul><li><code>LEFT JOIN</code>左外连接表示所有左表的记录都会返回，如果右表没有相匹配的结果，对应位置置为NULL</li><li><code>OUTER</code>关键字一般省去</li><li>为使得语句清晰，外连接尽量使用左连接</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> customers c<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> orders o<span class="hljs-keyword">ON</span> c.customer_id <span class="hljs-operator">=</span> o.customer_id;</code></pre></div><ul><li>多表连接时候，判断左右表关系似乎是按照<code>ON</code>来的，有待补充</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> customers c<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> orders o<span class="hljs-keyword">ON</span> c.customer_id <span class="hljs-operator">=</span> o.customer_id<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> shippers sh<span class="hljs-keyword">ON</span> o.shipper_id <span class="hljs-operator">=</span> sh.shipper_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> c.customer_id;</code></pre></div><ul><li>和内连接类似，外连接也可以自连接</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> employees m<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> emplyees m<span class="hljs-keyword">ON</span> e.reports_to <span class="hljs-operator">=</span> m.emplyee_id;</code></pre></div><ul><li>当两个表的列名完全一样时，使用<code>USING</code>简化，<code>USING</code>同样适用于有多个列作为键码的情况</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o<span class="hljs-keyword">JOIN</span> customers c<span class="hljs-comment">-- ON o.customer_id = c.customer_id</span><span class="hljs-keyword">USING</span> (customer_id);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> order_items oi<span class="hljs-keyword">JOIN</span> order_items_notes oin<span class="hljs-comment">-- ON oi.order_id = oin.order_id</span><span class="hljs-comment">-- AND oi.product_id = oin.product_id;</span><span class="hljs-keyword">USING</span> (order_id, product_id);</code></pre></div><ul><li><code>NATURAL JOIN</code>自然连接，使用同名的属性组，并且在结果中把重复的属性列去掉，不建议使用</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o<span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> customers c;</code></pre></div><ul><li><code>CROSS JOIN</code>交叉连接，返回笛卡尔积，即所有的组合结果</li><li>第一句为显式写法，第二句为隐式写法</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o<span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> customers c;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o, customers c;</code></pre></div><ul><li><code>UNION</code>联合查询结果，两次<code>SELECT</code>必须有相同的属性数，属性名以第一次查询为主进行整合</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name<span class="hljs-keyword">FROM</span> archived_orders<span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> name<span class="hljs-keyword">FROM</span> orders;</code></pre></div><h1 id="插入、更新、删除"><a href="#插入、更新、删除" class="headerlink" title="插入、更新、删除"></a>插入、更新、删除</h1><ul><li><code>INSERT INTO</code>插入单行</li><li><code>DEFAULT</code>可用于存在默认值或递增的属性</li><li><code>NULL</code>可用于允许空值的属性</li><li>可以指定要插入的列</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> customers<span class="hljs-keyword">VALUES</span> (  <span class="hljs-keyword">DEFAULT</span>,   <span class="hljs-string">&#x27;John&#x27;</span>,   <span class="hljs-string">&#x27;Smith&#x27;</span>,   <span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;address&#x27;</span>,<span class="hljs-string">&#x27;city&#x27;</span>,<span class="hljs-string">&#x27;CA&#x27;</span>,<span class="hljs-number">200</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> customers (first_name,last_name,birth_date,address,city,state)<span class="hljs-keyword">VALUES</span> (  <span class="hljs-string">&#x27;John&#x27;</span>,   <span class="hljs-string">&#x27;Smith&#x27;</span>,   <span class="hljs-string">&#x27;1990-01-01&#x27;</span>,<span class="hljs-string">&#x27;address&#x27;</span>,<span class="hljs-string">&#x27;city&#x27;</span>,<span class="hljs-string">&#x27;CA&#x27;</span>);</code></pre></div><ul><li>使用<code>VALUES</code>也可以一次插入多行</li><li>在删除一些行的情况下，自增的属性值依然会记住他们，即出现递增属性不连续</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> shippers (name)<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Shipper1&#x27;</span>), (<span class="hljs-string">&#x27;Shipper2&#x27;</span>), (<span class="hljs-string">&#x27;Shipper3&#x27;</span>);</code></pre></div><ul><li><code>LAST_INSERT_TO()</code>获得最新执行成功的<code>INSERT</code>语句的自增id</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders (customer_id, order_date, status)<span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2019-01-01&#x27;</span>, <span class="hljs-number">1</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> order_items<span class="hljs-keyword">VALUES</span>     (last_insert_id(), <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2.5</span>),    (last_insert_id(), <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1.5</span>);</code></pre></div><ul><li><code>CREATE TABLE</code>可以通过<code>SELECT</code>语句创建基于查询的复制表，属性不再拥有自增，主键等性质</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders_archived <span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders;</code></pre></div><ul><li><code>UPDATE</code>关键字可用于更新表中的某些行</li></ul><div class="code-wrapper"><pre><code class="hljs sql">UPDATE invoices<span class="hljs-keyword">SET</span> payment_total <span class="hljs-operator">=</span> <span class="hljs-number">0.5</span> <span class="hljs-operator">*</span> invoice_total,     payment_date <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2019-01-01&#x27;</span><span class="hljs-keyword">WHERE</span> invoice_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;</code></pre></div><ul><li><code>UPDATE</code>操作也可以结合子查询使用</li><li>子查询添加括号确保先执行</li><li>子查询返回多个数据时应使用<code>IN</code>关键字</li></ul><div class="code-wrapper"><pre><code class="hljs sql">UPDATE invoices<span class="hljs-keyword">SET</span> payment_total <span class="hljs-operator">=</span> <span class="hljs-number">567</span>, payment_date <span class="hljs-operator">=</span> due_date<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span>             (<span class="hljs-keyword">SELECT</span> client_id             <span class="hljs-keyword">FROM</span> clients            <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Yadel&#x27;</span>);UPDATE invoices<span class="hljs-keyword">SET</span> payment_total <span class="hljs-operator">=</span> <span class="hljs-number">567</span>, payment_date <span class="hljs-operator">=</span> due_date<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-keyword">IN</span>             (<span class="hljs-keyword">SELECT</span> client_id             <span class="hljs-keyword">FROM</span> clients            <span class="hljs-keyword">WHERE</span> state <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;CA&#x27;</span>, <span class="hljs-string">&#x27;NY&#x27;</span>));</code></pre></div><ul><li><code>DELETE</code>关键字用于删除</li><li><code>WHERE</code>可选，省略将删除表的所有记录</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span>             (<span class="hljs-keyword">SELECT</span> client_id              <span class="hljs-keyword">FROM</span> clients            <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Myworks&#x27;</span>);</code></pre></div><h1 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h1><ul><li>Mysql内置有<code>MAX()</code>，<code>MIN()</code>，<code>AVG()</code>，<code>SUM()</code>，<code>COUNT()</code>等聚合函数</li><li>聚合函数不仅可以用于列，也可以用于表达式</li><li>聚合函数会忽略空值，对于<code>COUNT()</code>函数需要注意</li><li><code>COUNT(*)</code>不会忽略空值，<code>*</code>表示全部数据</li><li>可以使用<code>DISTINCT</code>筛掉列的重复值</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     <span class="hljs-built_in">MAX</span>(invoice_date) <span class="hljs-keyword">AS</span> latest_date,      <span class="hljs-built_in">MIN</span>(invoice_total) lowest,    <span class="hljs-built_in">AVG</span>(invoice_total) average,    <span class="hljs-built_in">SUM</span>(invoice_total <span class="hljs-operator">*</span> <span class="hljs-number">1.1</span>) total,    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) total_records,    <span class="hljs-built_in">COUNT</span>(invoice_total) number_of_invoices,     <span class="hljs-built_in">COUNT</span>(payment_date) number_of_payments,      <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> client_id) number_of_distinct_clients<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> invoice_date <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2019-07-01&#x27;</span>;</code></pre></div><ul><li><code>GROUP BY</code>配合聚合函数使用，进行分组统计</li><li>注意<code>WHERE</code>，<code>GROUP BY</code>，<code>ORDER BY</code>的先后顺序</li><li><code>GROUP BY</code>也可以多列组合为依据分组，逗号分隔即可</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     client_id,      <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> invoice_date <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2019-07-01&#x27;</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> total_sales <span class="hljs-keyword">DESC</span>;<span class="hljs-keyword">SELECT</span>     state,    city,    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">JOIN</span> clients <span class="hljs-keyword">USING</span> (client_id) <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> state, city  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> state;</code></pre></div><ul><li><code>HAVING</code>关键字对<code>SELECT</code>后的结果列进行事后筛选，通常用于分组聚合后查询</li><li><code>HAVING</code>和 <code>WHERE</code> 都是是条件筛选语句，条件写法相通</li><li><code>HAVING</code>使用结果列明，<code>WHERE</code>使用原表列名</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     client_id,    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales,    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span><span class="hljs-operator">/</span>invoice_total<span class="hljs-operator">/</span>invoice_date) <span class="hljs-keyword">AS</span> number_of_invoices<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id<span class="hljs-keyword">HAVING</span> total_sales <span class="hljs-operator">&gt;</span> <span class="hljs-number">500</span> <span class="hljs-keyword">AND</span> number_of_invoices <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span>;</code></pre></div><ul><li>Mysql提供了<code>ROLLUP</code>运算符对聚合值进行汇总，如下将返回各客户的发票总额以及所有人的总发票额</li><li><code>ROLLUP</code>不是标准的SQL语言</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     client_id,    <span class="hljs-built_in">SUM</span>(invoice_total)<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>;</code></pre></div><ul><li>当<code>GROUP BY</code>取多列时，<code>ROLLUP</code>可以进行多层汇总</li><li>下面将返回各州的各市的发票总额以及州层次和全国层次的汇总额</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     state,    city,    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">JOIN</span> clients <span class="hljs-keyword">USING</span> (client_id) <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> state, city <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>;</code></pre></div><ul><li>使用<code>ROLLUP</code>时，<code>GROUP BY</code>不能使用列别名</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     pm.name <span class="hljs-keyword">AS</span> payment_method,    <span class="hljs-built_in">SUM</span>(amount) <span class="hljs-keyword">AS</span> total<span class="hljs-keyword">FROM</span> payments p<span class="hljs-keyword">JOIN</span> payment_methods pm    <span class="hljs-keyword">ON</span> p.payment_method <span class="hljs-operator">=</span> pm.payment_method_id<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> pm.name <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>;</code></pre></div><h1 id="编写复杂查询"><a href="#编写复杂查询" class="headerlink" title="编写复杂查询"></a>编写复杂查询</h1><ul><li>Mysql将先执行括号内的子查询，之后将结果返回给外查询</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> products<span class="hljs-keyword">WHERE</span> unit_price <span class="hljs-operator">&gt;</span> (    <span class="hljs-keyword">SELECT</span> unit_price    <span class="hljs-keyword">FROM</span> products    <span class="hljs-keyword">WHERE</span> product_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> products<span class="hljs-keyword">WHERE</span> product_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> product_id    <span class="hljs-keyword">FROM</span> order_items);</code></pre></div><ul><li>子查询将一张表的查询结果作为另一张表的查询依据并层层嵌套；链接将这些表合并成一个包含所需全部信息的详情表再直接在详情表里筛选查询；两种方法一般是可互换的，具体用哪一种取决于效率和可读性</li><li>例：查找从未订购过的顾客，下面两种方法均可达到效果</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> clients<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> client_id    <span class="hljs-keyword">FROM</span> invoices);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> clients<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> invoices <span class="hljs-keyword">USING</span> (client_id)<span class="hljs-keyword">WHERE</span> invoices_id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;</code></pre></div><ul><li>例：选出买过生菜（id = 3）的顾客的id，姓和名，采用混合子查询+表连接的方法</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> customer_id, first_name, last_name<span class="hljs-keyword">FROM</span> customers<span class="hljs-keyword">WHERE</span> customer_id <span class="hljs-keyword">IN</span> (      <span class="hljs-keyword">SELECT</span> customer_id    <span class="hljs-keyword">FROM</span> orders    <span class="hljs-keyword">JOIN</span> order_items <span class="hljs-keyword">USING</span> (order_id)      <span class="hljs-keyword">WHERE</span> product_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>);</code></pre></div><ul><li><code>ALL</code>关键字代表集合中的任意记录</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> invoice_total <span class="hljs-operator">&gt;</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(invoice_total)    <span class="hljs-keyword">FROM</span> invoices    <span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> invoice_total <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALL</span> (    <span class="hljs-keyword">SELECT</span> invoice_total    <span class="hljs-keyword">FROM</span> invoices    <span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>);</code></pre></div><ul><li><code>ANY</code>关键字代表集合中存在某条记录，可与<code>MIN</code>等效</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> invoice_total <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ANY</span> (<span class="hljs-keyword">SELECT</span> invoice_total<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> invoice_total <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(invoice_total)<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>);</code></pre></div><ul><li><code>ANY</code>某些时候也可与<code>IN</code>等效</li><li>例：选择至少有两次发票记录的顾客</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> clients<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> client_id    <span class="hljs-keyword">FROM</span> invoices    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span>);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> clients<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> <span class="hljs-keyword">ANY</span> (     <span class="hljs-keyword">SELECT</span> client_id    <span class="hljs-keyword">FROM</span> invoices    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span>);</code></pre></div><ul><li>在上面的子查询中，子查询与主查询无关，可以先进行完子查询，再进行主查询</li><li>相关子查询，子查询与主查询有关</li><li>例：返回各部门中工资超过该部门平均值的人，对于<code>employees e</code>中的每条记录，都将执行一次子查询</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> employees e  <span class="hljs-comment">-- 关键 1</span><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary)    <span class="hljs-keyword">FROM</span> employees    <span class="hljs-keyword">WHERE</span> office_id <span class="hljs-operator">=</span> e.office_id  <span class="hljs-comment">-- 关键 2</span>    <span class="hljs-comment">-- 【子查询表字段不用加前缀，主查询表的字段要加前缀，以此区分】</span>);</code></pre></div><ul><li><code>EXISTS</code>关键字如果集合不为空返回<code>TRUE</code>，否则返回<code>FALSE</code></li><li><code>IN + 子查询</code> 等效于 <code>EXIST + 相关子查询</code>，如前者子查询结果集过大占用内存，后者逐条验证更有效率</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> clients<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> client_id    <span class="hljs-keyword">FROM</span> invoices);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> clients c<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>    <span class="hljs-comment">-- 就这个子查询的目的来说，SELECT的选择不影响结果，</span>    <span class="hljs-comment">-- 因为EXISTS()函数只根据是否为空返回结果</span>    <span class="hljs-keyword">FROM</span> invoices    <span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> c.client_id);</code></pre></div><ul><li><code>EXISTS()</code>返回的是 <code>TRUE/FALSE</code>，所以也可以加上<code>NOT</code>取反</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> product_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">FROM</span> order_items);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> products p<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>    <span class="hljs-keyword">FROM</span> order_items    <span class="hljs-keyword">WHERE</span> product_id <span class="hljs-operator">=</span> p.product_id);</code></pre></div><ul><li>例：经典题目，选择没有选所有课的学生</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 选择没有选所有课的学生</span><span class="hljs-comment">-- 存在某一样课，该学生没有对应的选课记录</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> stu s<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span>(  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>  <span class="hljs-keyword">FROM</span> class c  <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>(      <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>      <span class="hljs-keyword">FROM</span> stu_class      <span class="hljs-keyword">WHERE</span> stu_id <span class="hljs-operator">=</span> s.stu_id <span class="hljs-keyword">AND</span> class_id <span class="hljs-operator">=</span> c.class_id    ));</code></pre></div><ul><li>子查询或相关子查询也可用于<code>SELECT</code>中</li><li>引用同级的列别名，需要使用<code>SELECT</code>，引用同级的列别名不需要说明来源</li><li>下面的例子中有三个子查询，第一个为相关子查询，表示某顾客订单总量，第二个为子查询，表示所有订单平均值，第三个引用同级的列别名，表示前两者的差</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     client_id,    name,    (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">FROM</span> invoices <span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> c.client_id) <span class="hljs-keyword">AS</span> total_sales,    (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(invoice_total) <span class="hljs-keyword">FROM</span> invoices) <span class="hljs-keyword">AS</span> average,    (<span class="hljs-keyword">SELECT</span> total_sales <span class="hljs-operator">-</span> average) <span class="hljs-keyword">AS</span> difference   <span class="hljs-keyword">FROM</span> clients c;</code></pre></div><ul><li>子查询也可用于<code>FROM</code>中</li><li>当子查询太复杂时应使用视图将子查询结果储存起来，使用视图作为来源表</li><li>在FROM中使用子查询，即使用 “派生表” 时，必须给派生表取个别名</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span>         client_id,        name,        (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">FROM</span> invoices <span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> c.client_id) <span class="hljs-keyword">AS</span> total_sales,        (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(invoice_total) <span class="hljs-keyword">FROM</span> invoices) <span class="hljs-keyword">AS</span> average,        (<span class="hljs-keyword">SELECT</span> total_sales <span class="hljs-operator">-</span> average) <span class="hljs-keyword">AS</span> difference       <span class="hljs-keyword">FROM</span> clients c) <span class="hljs-keyword">AS</span> sales_summury<span class="hljs-keyword">WHERE</span> total_sales <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;</code></pre></div><h1 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h1><p>内置的用来处理数值、文本、日期等的函数</p><ul><li>数值函数</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ROUND(<span class="hljs-number">5.7365</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">-- 四舍五入</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">TRUNCATE</span>(<span class="hljs-number">5.7365</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">-- 截断</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CEILING</span>(<span class="hljs-number">5.2</span>)  <span class="hljs-comment">-- 天花板函数，大于等于此数的最小整数</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">5.6</span>)  <span class="hljs-comment">-- 地板函数，小于等于此数的最大整数</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">ABS</span>(<span class="hljs-number">-5.2</span>)  <span class="hljs-comment">-- 绝对值</span><span class="hljs-keyword">SELECT</span> RAND()  <span class="hljs-comment">-- 随机函数，0到1的随机值</span></code></pre></div><ul><li>字符串函数</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> LENGTH(<span class="hljs-string">&#x27;sky&#x27;</span>)  <span class="hljs-comment">-- 字符串字符个数</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">UPPER</span>(<span class="hljs-string">&#x27;sky&#x27;</span>)  <span class="hljs-comment">-- 转大写</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">LOWER</span>(<span class="hljs-string">&#x27;Sky&#x27;</span>)  <span class="hljs-comment">-- 转小写</span><span class="hljs-keyword">SELECT</span> LTRIM(<span class="hljs-string">&#x27;  Sky&#x27;</span>)  <span class="hljs-comment">-- 去除左多余空格</span><span class="hljs-keyword">SELECT</span> RTRIM(<span class="hljs-string">&#x27;Sky  &#x27;</span>)  <span class="hljs-comment">-- 去除右多余空格</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">TRIM</span>(<span class="hljs-string">&#x27; Sky &#x27;</span>)  <span class="hljs-comment">-- 去除多余空格</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">LEFT</span>(<span class="hljs-string">&#x27;Kindergarden&#x27;</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment">-- 取左4个字符</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">RIGHT</span>(<span class="hljs-string">&#x27;Kindergarden&#x27;</span>, <span class="hljs-number">6</span>)  <span class="hljs-comment">-- 取右6个字符</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUBSTRING</span>(<span class="hljs-string">&#x27;Kindergarden&#x27;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>)  <span class="hljs-comment">-- 从第7个开始长度为6的子串，省略长度参数则取到末端</span><span class="hljs-keyword">SELECT</span> LOCATE(<span class="hljs-string">&#x27;gar&#x27;</span>, <span class="hljs-string">&#x27;Kindergarden&#x27;</span>)  <span class="hljs-comment">-- 定位首次出现的位置，没有的话返回0，不区分大小写</span><span class="hljs-keyword">SELECT</span> REPLACE(<span class="hljs-string">&#x27;Kindergarten&#x27;</span>, <span class="hljs-string">&#x27;garten&#x27;</span>, <span class="hljs-string">&#x27;garden&#x27;</span>)  <span class="hljs-comment">-- 替换</span><span class="hljs-keyword">SELECT</span> CONCAT(f_name, <span class="hljs-string">&#x27; &#x27;</span>, l_name) <span class="hljs-keyword">AS</span> f_name <span class="hljs-keyword">FROM</span> customers  <span class="hljs-comment">-- 连接</span></code></pre></div><ul><li>处理时间日期的函数</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 当前时间日期对象</span><span class="hljs-keyword">SELECT</span> NOW()  <span class="hljs-comment">-- 2021-08-27 08:50:46</span><span class="hljs-keyword">SELECT</span> CURDATE()  <span class="hljs-comment">-- 2021-08-27</span><span class="hljs-keyword">SELECT</span> CURTIME()  <span class="hljs-comment">-- 08:50:46</span><span class="hljs-comment">-- 提取时间日期对象中的元素</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">YEAR</span>(NOW())  <span class="hljs-comment">-- 2021</span><span class="hljs-keyword">SELECT</span> DAYNAME(NOW())  <span class="hljs-comment">-- Saturday</span><span class="hljs-keyword">SELECT</span> MONTHNAME(NOW())  <span class="hljs-comment">-- September</span></code></pre></div><ul><li>日期格式化，格式说明符里，大小写是不同的，这是目前SQL里第一次出现大小写不同的情况</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATE_FORMAT(NOW(), <span class="hljs-string">&#x27;%M %d, %Y&#x27;</span>)  <span class="hljs-comment">-- September 12, 2020</span><span class="hljs-keyword">SELECT</span> TIME_FORMAT(NOW(), <span class="hljs-string">&#x27;%H:%i %p&#x27;</span>)  <span class="hljs-comment">-- 11:07 AM</span></code></pre></div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1UE41147KC?p=34">伟大的海伦君.SQL进阶教程</a></p><p><a href="https://zhuanlan.zhihu.com/p/222865842">ASC2050.Mosh完全掌握SQL笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图解计算机网络笔记</title>
    <link href="/2021/08/07/%E5%9B%BE%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/07/%E5%9B%BE%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文章原意是对《图解计算机网络》一书的笔记。但在阅读本书过程中，参考了网络上大量资料（每章参考资料在最后给出），已经不单单是“笔记”了。由于博客是基于我自己的知识基础，为了参加面试对网络资料进行整理得到的，可能不适用于希望对计算机网络有一个完整、大概认识的同学。</p><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>通过光缆、电缆、双绞线、无线电波等方式将电脑连接起来，将数据包转化为0和1的电信号进行传输，主要规定网络的一些电气特性。</p><h2 id="链接层"><a href="#链接层" class="headerlink" title="链接层"></a>链接层</h2><p>链接层规定了0和1的分组方式，即如何解读获得的01串。</p><p><strong>以太网协议</strong></p><p>以太网协议规定，一组电信号构成一个数据包：“帧”，每一帧包括标头（Head）和数据（Data）。</p><p>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p><p>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><p><strong>MAC地址</strong></p><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，叫做MAC地址。</p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示，如<code>00-B0-D0-86-BB-F7</code>，前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><p><strong>广播</strong></p><p>以太网数据包必须知道接收方的MAC地址，然后才能发送，需要用到ARP协议，这个留到后面介绍。</p><p>有了MAC地址后，为了把数据包准确送到接收方，以太网采用了一种很”原始”的方式，它向本网络内所有计算机发送数据包，每台计算机自己判断是否为接收方。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p><strong>在网络间传输</strong></p><p>互联网是无数子网络共同组成的一个巨型网络，以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。”路由”，就是指如何向不同的子网络分发数据包。遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p><p>这就导致了”网络层”的诞生。它引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</p><p>“网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p><p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p><p><strong>IP协议</strong></p><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p><p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成，习惯上，我们用分成四段的十进制数表示IP地址，从<code>0.0.0.0</code>一直到<code>255.255.255.255</code>。</p><p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。</p><p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。</p><p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址<code>172.16.254.1</code>，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是<code>255.255.255.0</code>。</p><p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算，如果结果相同的话，就表明它们在同一个子网络中。</p><p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p><p><strong>IP数据包</strong></p><p>IP数据包在传输过程中会被放到以太网数据包的“数据”部分，分为”标头”和”数据”两个部分。</p><p>“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。</p><p>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此理论上，一个IP数据包的”数据”部分最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p><p><strong>ARP协议</strong></p><p>在发送方发送数据时，因为IP数据包是放在以太网数据包里发送的，所以我们必须知道对方的MAC地址和对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p><p>所以，我们需要一种机制，能够从IP地址得到MAC地址，这里可以分成两种情况。</p><p>第一种情况，两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p><p>第二种情况，两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是<code>FF:FF:FF:FF:FF:FF</code>，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，做出回复，向对方报告自己的MAC地址。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p><strong>端口到端口通信</strong></p><p>有了MAC地址和IP地址，可以在互联网上任意两台主机上建立通信。</p><p>问题是，同一台主机上有许多进程需要用到网络，也就是说，我们还需要一个参数，表示这个数据包到底供哪个进程使用。这个参数就叫做”端口”（port），它是每一个使用网卡的进程的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>“端口”是0到65535之间的一个整数，16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p><p>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p><p><strong>UDP协议</strong></p><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p><p>UDP数据包，也是由”标头”和”数据”两部分组成。”标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分。</p><p>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><p><strong>TCP协议</strong></p><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p><p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p><p>TCP协议并不能够确保数据不会遗失，但是可以确保数据一旦遗失，接收方可以得知这件事。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>“应用层”的作用，就是规定应用程序的数据格式。</p><p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p><p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。</p><p>应用软件在应用层实现，应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的。当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。</p><p>应用层工作在操作系统中的用户态，传输层及以下工作在内核态。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">阮一峰.互联网协议入门(一)</a></p><h1 id="HTTP-篇"><a href="#HTTP-篇" class="headerlink" title="HTTP 篇"></a>HTTP 篇</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><p>HTTP 是超文本传输协议，也就是<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p></li><li><p><strong>常见的状态码</strong></p><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记3.png?raw=true" alt=""></p></li><li><p><strong>http常⻅字段</strong></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">客户端发送请求时：</span><span class="hljs-attr">Host:</span> <span class="hljs-string">www.A.com</span><span class="hljs-string">指定服务器域名</span><span class="hljs-attr">Connection:</span> <span class="hljs-string">keep-alive</span><span class="hljs-string">最常用于客户端要求服务器使用</span> <span class="hljs-string">TCP</span> <span class="hljs-string">持久连接，以便其他请求复用</span><span class="hljs-attr">Accept:</span> <span class="hljs-string">*/*</span><span class="hljs-string">客户端声明自己可以接受哪些数据格式，*/*表示接受任何格式</span><span class="hljs-attr">Accept-Encoding:</span> <span class="hljs-string">gzip,</span> <span class="hljs-string">deflate</span><span class="hljs-string">说明自己可以接受哪些压缩方法</span><span class="hljs-string">服务器响应请求时：</span><span class="hljs-attr">Content-Length:</span> <span class="hljs-number">1000</span><span class="hljs-string">表明本次回应的数据⻓度1000字节</span><span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/html;</span> <span class="hljs-string">charset=utf-8</span><span class="hljs-string">服务器表明自己发送的数据格式，发送的是网⻚，编码为UTF-8</span><span class="hljs-attr">Content-Encoding:</span> <span class="hljs-string">gzip</span> <span class="hljs-string">表示服务器返回的数据使用gzip压缩格式</span></code></pre></div></li><li><p><strong>GET与POST</strong></p><p>Get请求从服务器获取资源；</p><p>POST向 <strong>URI</strong> 指定的资源提交数据，数据就放在报文的 body 里，服务器响应代表处理结果。</p><p><strong>安全</strong>指请求方法不会破坏服务器上的资源， <strong>幂等</strong>指多次执行相同的操作，结果都是相同的。</p><p>GET方法就是安全且幂等的，POST是不安全的不幂等的。</p></li></ol><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p class="note note-primary">  <b>HTTP/1.1特点</b></p><p><strong>简单</strong>：基本的报文格式就是 header + body ，头部信息也是 key-value 简单文本的形式；</p><p><strong>灵活</strong>：各类请求方法、URI/URL、状态码、头字段等都允许开发人员自定义和扩充，HTTP 工作在应用层，下层可以随意变化；</p><p><strong>无状态</strong>：服务器不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，对于关联性操作可以使用 Cookie技术解决；</p><p><strong>明文传输</strong>：在传输过程中的信息，是可方便阅读的，这种特性同时也有很大的安全隐患。</p><p class="note note-primary">  <b>HTTP/1.1如何优化</b></p><ol><li><p>减少HTTP请求次数</p><p><span class="label label-primary">缓存</span></p><p>服务器在返回资源的时候，同时返回一个预估的过期时间，客户端以URL作为key，资源作为value的形式存储在本地。在此访问同URL时，先查询本地磁盘，如果存在：若未过期，直接返回资源；否则，再次发起请求，并附带本地过期资源的摘要，若服务器发现资源未变动，直接返回不含有包体的 <strong>304 Not Modified</strong> 响应，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时。</p><p><span class="label label-primary">重定向服务交给代理服务器</span></p><p><span class="label label-primary">合并请求</span></p><p>如将小图片合为一张大图片，js、css等小资源合为一个文件。以一个大资源的请求替换多个小资源的请求。 但当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件，带来了额外的网络消耗。</p><p><span class="label label-primary">延迟发送请求 </span></p><p>按需获取。请求网⻚的时候只获取当前用户所看到的⻚面资源，当用户向下滑动⻚面的时候，再向服务器获取接下来的资源。</p></li><li><p>减少HTTP响应数据大小</p><p><span class="label label-primary">无损压缩、有损压缩</span></p></li></ol><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>加密算法分为以下两种：</p><p><span class="label label-primary"><b>对称加密</b></span></p><ul><li>甲方选择某一种加密规则，对信息进行加密；乙方使用同一种规则，对信息进行解密；</li><li>加密和解密使用同样规则（简称”<strong>密钥</strong>“）。</li></ul><p>甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。</p><p>后来，人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。</p><p><span class="label label-primary"><b>不对称加密：公钥加密法</b></span></p><ul><li>乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的；甲方获取乙方的公钥，然后用它对信息加密。乙方得到加密后的信息，用私钥解密；</li><li>公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立；</li><li>所有的（公钥, 私钥）对都是不同的；</li><li><strong>用公钥可以解开私钥加密的信息，反之亦成立</strong>；</li><li>同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的；</li><li>在双钥体系中，<strong>公钥用来加密信息，私钥用来数字签名</strong>。</li></ul><p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>不对称加密过程中，双方的通信是建立在公钥可信的基础上的：</p><ol><li>B对数据进行Hash生成<strong>摘要</strong>后，使用私钥对摘要进行加密，生成<strong>数字签名</strong>；B将数据和数字签名一同发给A；</li><li>A对数据进行相同的Hash，并对数字签名使用B的公钥解密；如果解密结果与Hash结果相同，则确认为B发出。</li></ol><p>如果一开始A拿到的公钥就是假的话，那么B后来发出的任何内容A均无法识别。问题在于A获取公钥的过程依然是明文传输的，为此提出数字证书的方法，通过可信的第三方（CA）对公钥进行签名，保证B的公钥通过可信的方式传递给A：</p><ol><li>CA使用私钥对B的公钥及相关信息如证书的颁布机构、有效期、持有者进行签名，生成数字证书；</li><li>B将数据，数字签名，数字证书一同发送给A；</li><li>CA的公钥也是需要使用证书来分发的，所以 A的电脑必须安装CA的证书，证书里包含CA的公钥。</li><li>A用CA的公钥解开数字证书，验证证书的可信性；从证书拿到B真实的公钥，验证”数字签名”是否真的是B签的。</li></ol><p><strong>为什么先进行摘要再进行签名？</strong></p><p>原数据过大，加密算法耗时。</p><h3 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h3><p>HTTP 由于是明文传输，所谓的明文，就是说客户端与服务端通信的信息都是肉眼可⻅的，随意使用一个抓包工具都可以截获通信的内容。<br>所以安全上存在以下三个⻛险</p><ul><li><strong>窃听风险</strong>：第三方可以获知通信内容；</li><li><strong>篡改风险</strong>：第三方可以修改通信内容；</li><li><strong>冒充风险</strong>：第三方可以冒充他人身份参与通信。</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加入了SSL/TLS协议，来解决上述的⻛险。</p><ul><li>所有信息都是<strong>加密传播</strong>，第三方无法窃听；</li><li>具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现；</li><li>配备<strong>身份证书</strong>，防止身份被冒充。</li></ul><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记1.png?raw=true" alt=""></p><p>SSL/TLS协议的基本思路是采用<a href="https://en.wikipedia.org/wiki/Public-key_cryptography">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p>但是，这里有两个问题。</p><ol><li><p>如何保证公钥不被篡改？</p><p>将公钥放在<a href="https://en.wikipedia.org/wiki/Digital_certificate">数字证书（CA）</a>中。只要证书是可信的，公钥就是可信的。</p></li><li><p>公钥加密计算量太大，如何减少耗用的时间？</p><p>采用<strong>混合加密</strong>。每一次对话，客户端和服务器端都生成一个”<strong>对话密钥</strong>“，用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p></li></ol><p>因此，SSL/TLS协议的基本过程是这样的：</p><ul><li><p>客户端向服务器端索要并验证公钥；</p></li><li><p>双方协商生成”对话密钥”；</p></li><li><p>双方采用”对话密钥”进行加密通信；</p></li></ul><p>上面过程的前两步，又称为”握手阶段”。</p><h3 id="SSL-TSL握手"><a href="#SSL-TSL握手" class="headerlink" title="SSL/TSL握手"></a>SSL/TSL握手</h3><p>基于RSA加密的握手过程，也是基础的SSL/TSL握手过程。</p><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记2.png?raw=true" alt=""></p><p><strong>1. 客户端发出请求（ClientHello）</strong></p><p>客户端向服务器发出加密通信的请求，称为ClientHello请求，客户端主要向服务器提供以下信息：</p><p class="note note-secondary">  （1）支持的协议版本，比如TLS 1.0版。  <br>  （2）一个客户端生成的随机数Client random，稍后用于生成"对话密钥"。  <br>  （3）支持的加密方法，比如RSA公钥加密。  <br>  （4）支持的压缩方法。</p><p><strong>2. 服务器回应（SeverHello）</strong></p><p>服务器的回应包含以下内容：</p><p class="note note-secondary">  （1）确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。  <br>  （2）一个服务器生成的随机数Server random，稍后用于生成"对话密钥"。  <br>  （3）确认使用的加密方法，比如RSA公钥加密。  <br>  （4）服务器证书。</p><p><strong>3. 客户端回应</strong></p><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p><p class="note note-secondary">  （1）一个随机数。该随机数用服务器公钥加密，防止被窃听。  <br>  （2）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。  <br>  （3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p><p> 此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p><p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p><p>值得注意的是，该过程之前的阶段均为明文传输；而pre-master key使用服务器公钥加密，之后客户端与服务器端均生成会话密钥，数据传输均为加密传输。</p><p><strong>4. 服务器的最后回应</strong></p><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p><p class="note note-secondary">  （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。  <br>  （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p><p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p><p>使用 RSA密钥协商算法的最大问题是不支持前向保密。整个握手阶段都不加密（也没法加密），都是明文的。如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。所以一旦服务端的私钥泄漏 了，过去被第三方截获的所有 TLS 通讯密文都会被破解。所以目前使用较多的为<strong>ECDHE加密法</strong>。</p><h3 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h3><p><strong>离散对数</strong></p><p>假定 a, p 均是素数，下面两个集合相等，证明过程请参考 <a href="http://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0133354695">Cryptography and Network Security</a> 第八章：</p><div class="code-wrapper"><pre><code class="hljs no">&#123; a^1 mod p, a^2 mod p, ..., a^(p-1) mod p &#125; = &#123;1, 2, ... , p-1 &#125;   &#123;&#125; 表示集合</code></pre></div><p>上述式子可概括成以下三点，对于 1 &lt;= x,y &lt;= p - 1，有：</p><ul><li>a^x mod p 一定属于 {1, 2, …, p -1 }</li><li>如果 x != y，则 a^x mod p != a^y mod p</li><li>对于 1 &lt;= b &lt;= p - 1，一定存在唯一的 1 &lt;= x &lt;= p-1，使得 b = a^x mod p</li></ul><p>第三点在求解上有这么一个特点：已知 x 求 b 非常容易，已知 b 求 x 非常困难，特别当 p 很大时，求解的复杂度非常高，所以它又被称为离散对数问题 (<a href="https://en.wikipedia.org/wiki/Discrete_logarithm">Discrete logarithm</a>)，它是 DH 算法能够安全交换密钥的基础</p><p><strong>求模公式</strong></p><p>假设 q 为素数，对于正整数 a,x,y，有：</p><div class="code-wrapper"><pre><code class="hljs no">(a^x mod p)^y mod p = a^(xy) mod p</code></pre></div><p>证明如下：</p><div class="code-wrapper"><pre><code class="hljs no">令 a^x = mp + n， 其中 m, n 为自然数， 0 &lt;= n &lt; p，则有C = (a^x mod p)^y mod p  = ((mp + n) mod p)^y mod p  = n^y mod p  = (mp +n)^y mod p  = a^(xy) mod p</code></pre></div><p><strong>Deffie-Hellman 算法</strong></p><ol><li>首先 A, B 共同选取 p 和 a 两个素数，p 和 a 均公开；</li><li>之后 A 选择一个自然数 Xa &lt; p，计算出 Ya = a^Xa mod p，Xa 保密，Ya 公开；</li><li>同理，B 选择 Xb &lt; p 并计算出 Yb = a^Xb mod p，其中 Xb 保密，Yb 公开；</li><li>A 用 Yb 和 Xa 计算出密钥 K = Yb^Xa mod p，而 B 用 Ya 和 Xb 计算密钥 K = Ya^Xb mod p。</li></ol><p>流程如下：</p><div class="code-wrapper"><pre><code class="hljs no">+-------------------------------------------------------------------+|                    Global Pulic Elements                          ||                                                                   ||       p                               prime number                ||       a                               prime number, a &lt; p         |+-------------------------------------------------------------------++-------------------------------------------------------------------+|                    User A Key Generation                          ||                                                                   ||       Select private Xa               Xa &lt; p                      ||       Calculate public Ya             Ya = a^Xa mod p             |+-------------------------------------------------------------------++-------------------------------------------------------------------+|                    User B Key Generation                          ||                                                                   ||       Select private Xb               Xb &lt; p                      ||       Calculate public Yb             Yb = a^Xb mod p             |+-------------------------------------------------------------------++-------------------------------------------------------------------+|               Calculation of Secret Key by User A                 ||                                                                   ||       Secret Key K                    K = Yb^Xa mod p             |+-------------------------------------------------------------------++-------------------------------------------------------------------+|               Calculation of Secret Key by User B                 ||                                                                   ||       Secret Key K                    K = Ya^Xb mod p             |+-------------------------------------------------------------------+</code></pre></div><p>下面证明，A 和 B 计算出来的密钥 K 相同。</p><div class="code-wrapper"><pre><code class="hljs no">K = Yb^Xa mod p  = (a^Xb mod p)^Xa mod p  = a^(Xa * Xb) mod p          根据上述求模公式  = (a^Xa mod p)^Xb mod p  = Ya^Xb mod p</code></pre></div><p>上面一共出现了 a, p, Xa, Ya, Xb, Yb, K 共 7 个数，其中：</p><ul><li>公开的数：a, p, Ya, Yb</li><li>非公开数：Xa, Xb, K</li></ul><p>通常情况下，a 一般为 2 或 5，而 p 的取值非常大，至少几百位，Xa 和 Xb 的取值也非常大，其复杂度至少为 <a href="https://en.wikipedia.org/wiki/Pollard&#39;s_rho_algorithm_for_logarithms">O(p^0.5)</a>。对于攻击者来说，已知 Ya，Xa 的求解非常困难，同理 Xb 的求解也很困难，所以攻击者难以求出 K，所以 DH 能够保证通信双方在<strong>透明</strong>的信道中安全的交换密钥。</p><p>DH 算法主要实现方法为<strong>DHE 算法</strong>，DHE 算法让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，E 全称是 ephemeral（临时性的）。这样就保证了 <strong>前向安全</strong>，即使曾经的通信过程被破解，不会影响现在的通信的安全性。</p><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">阮一峰.RSA算法原理（一）</a></p><p><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">阮一峰.SSL/TLS协议运行机制的概述</a></p><p><a href="https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">阮一峰.图解SSL/TLS协议</a></p><p><a href="https://juejin.cn/post/6895624327896432654#heading-9">洛禹Keith.TLS 详解握手流程</a></p><p><a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">小林coding.图解 HTTP 常见的面试题</a></p><p><a href="https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">阮一峰.数字签名是什么</a></p><p><a href="http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html">阮一峰.密码学笔记</a></p><p><a href="https://segmentfault.com/a/1190000024523772">编程指北.加密、数字签名和数字证书</a></p><p><a href="http://wsfdl.com/algorithm/2016/02/04/理解Diffie-Hellman密钥交换算法.html">koala bear.理解 Deffie-Hellman 密钥交换算法</a></p><h1 id="TCP-篇"><a href="#TCP-篇" class="headerlink" title="TCP 篇"></a>TCP 篇</h1><p>TCP是<code>面向连接</code>的、<code>可靠</code>的、<code>基于字节流</code>的传输层通信协议。</p><h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h2><p>在介绍三次握手，四次挥手的过程之前，需要了解TCP头部的一些知识</p><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记4.png?raw=true" alt=""></p><ul><li><code>源端口</code>和目的端口：确定主机中的进程；</li><li>序号(seq)：报文段中的的第一个数据字节在数据流中的序号，主要用来解决网络报乱序的问题；</li><li>确认号(ack_seq)：所期望收到的下一个数据包的序号；</li><li>ACK：1有效，表示已经收到数据包</li><li>RST：1有效，连接复位请求</li><li>SYN：1有效，表示申请与接收方建立连接</li><li>FIN：1有效，表示申请与接收方断开连接</li></ul><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><blockquote><p>在Google Groups的<a href="https://groups.google.com/forum/#!forum/pongba">TopLanguage</a>中看到一帖讨论TCP“三次握手”觉得很有意思。贴主提出“<a href="https://groups.google.com/forum/#!topic/pongba/kF6O7-MFxM0/discussion">TCP建立连接为什么是三次握手？</a>”的问题，在众多回复中，有<a href="https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ">一条回复</a>写道：“这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”。</p></blockquote><p>网络中A与B要建立TCP连接，可以分为以下四步：</p><div class="code-wrapper"><pre><code class="hljs no">（1）A请求向B发送消息（2）B向A表示同意（3）B请求向A发送消息（4）A向B表示同意</code></pre></div><p>可以发现，由于(2)(3)过程均为B向A发送消息，所以合为一次握手，实际上TCP建立连接只需要三次握手即可。</p><p>接下来介绍三次握手的具体过程</p><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记5.png?raw=true" alt=""></p><p class="note note-secondary">  （1）A发送SYN=1，seq初始化为随机值X的连接请求报文段，之后进入SYN_SEND状态；  <br>  （2）收到连接请求前，B可以认为处于LISTEN阶段；收到连接请求后，B向A发送一个响应+请求报文段，置ACK=1，SYN=1，ack_seq=X+1，seq初始化为随机值Y，B进入SYN_RCVD状态；  <br>  （3）A响应B的连接请求，向B发送一个ACK=1的报文段，置seq=X+第一次握手报文长度1，ack_seq=Y，之后A进入ESTABLISHED状态；  <br>  （4）B收到A响应后同样进入ESTABLISHED状态，连接建立完成。</p><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记6.png?raw=true" alt=""></p><p>挥手过程，A与B断开连接之后，B可能还会有需要发个A的数据，不能立刻断开连接，需要有一个CLOSE_WAIT的过程，不能合为三次。</p><p class="note note-secondary">  （1）A将FIN置为1，ACK置为1，seq设置为X=上一次对方传送过来的ack_seq，ack_seq设置为Y=为上一次对方传过来的seq+1。将数据发送至B，然后A进入FIN_WAIT_1状态；  <br>  （2）B收到了A发送的FIN报文段，向A回复，将ACK置为1，seq设置为Y，ack_seq设置为X+1。然后B进入CLOSE_WAIT状态，A收到B的回复后，进入FIN_WAIT_2状态；  <br>  （3）B再次向A发送报文，FIN置为1，ACK置为1，seq设置为Y，ack_seq设置为X+1，然后B进入LAST_ACK状态，A收到B的报文后，进入TIME_WAIT状态；  <br>  （4）A收到B发送的FIN报文段，向B回复，ACK置为1，seq设置为X+1，ack_seq设置为Y+1。然后A进入TIME_WAIT状态，B在收到报文后进入CLOSED状态。A在发送完报文等待了2MSL时间后进入CLOSED状态。</p><p><strong>为什么 TIME_WAIT 状态要等待 2MSL 之后才关闭连接</strong></p><ul><li>2MSL表示两个MSL的时长，MSL全称为Maximum Segment Life，表示TCP Segment 生存时间的限制。</li><li>为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST_ACK状态的B收不到对自己已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段。而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后A和B都正常进入到CLOSED状态。如果A在TIME_WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而也不会在发送一次确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。</li><li>使下一个新的连接中不会出现这种旧的连接请求报文段。A在发送完最后一个ACK报文段后，在经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。</li></ul><h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.jiar.me/2017/08/11/TCP三次握手简介/">Jiar.TCP三次握手简介</a></p><p><a href="https://blog.jiar.me/2017/08/24/TCP四次挥手简介/">Jiar.TCP四次挥手简介</a></p><h1 id="IP篇"><a href="#IP篇" class="headerlink" title="IP篇"></a>IP篇</h1><h1 id="网络安全篇"><a href="#网络安全篇" class="headerlink" title="网络安全篇"></a>网络安全篇</h1><h2 id="安全攻击分类"><a href="#安全攻击分类" class="headerlink" title="安全攻击分类"></a>安全攻击分类</h2><p><span class="label label-primary">被动攻击</span>：攻击者窃听监听数据传输，从而获取到传输的数据信息。主要有：消息内容泄露攻击和流量分析攻击。由于并没有修改数据，这种攻击是很难被检测到的。</p><p><span class="label label-primary">主动攻击</span>：攻击者修改传输的数据流或者故意添加错误的数据流，如假冒用户身份从而得到一些权限，进行权限攻击，除此之外，还有重放、改写和拒绝服务等。</p><h2 id="参考资料-3"><a href="#参考资料-3" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/">Leetcode.计算机网络面试突击</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经</title>
    <link href="/2021/08/06/%E9%9D%A2%E7%BB%8F/"/>
    <url>/2021/08/06/%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="C-C-static关键字作用"><a href="#C-C-static关键字作用" class="headerlink" title="C/C++ static关键字作用"></a>C/C++ static关键字作用</h1><ol><li><p>隐藏：当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p></li><li><p>全局生命周期：存储在静态数据区的变量会在程序刚开始运行时就完成唯一的一次初始化。 共有两种变量存储在静态存储区：全局变量和static变量，与全局变量相比，static可以控制变量的可见范围。</p></li><li><p>变量默认初始化为0：在静态数据区，内存中所有的字节默认值都是0x00，所以全局变量也具备这一属性。</p></li><li><p>C++中的类成员声明static</p><ul><li>static修饰的变量或函数是属于类的，所有对象只有一份拷贝。 因此，不能将静态函数设为虚函数。  </li><li>静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）  </li></ul></li></ol><h1 id="vector是如何扩容的"><a href="#vector是如何扩容的" class="headerlink" title="vector是如何扩容的"></a>vector是如何扩容的</h1><p>往vector中添加元素时，如果空间不够将会导致扩容。vector有两个属性：size和capacity。size表示已经使用的数据容量，capacity表示数组的实际容量，包含已使用的和未使用的。</p><p>vector扩容规则：</p><ol><li>当数组大小不够容纳新增元素时，开辟更大的内存空间，把旧空间上的数据复制过来，然后在新空间中继续增加。</li><li>新的更大的内存空间，一般是当前空间的1.5倍或者2倍，这个1.5或者2被称为扩容因子，不同系统实现扩容因子也不同。</li></ol><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><p>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在统一作用域中。</p><p>覆盖：子类继承父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写。</p><p>重写：</p><p>（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。<br>（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</p><h1 id="2-5亿个数求不重复数"><a href="#2-5亿个数求不重复数" class="headerlink" title="2.5亿个数求不重复数"></a>2.5亿个数求不重复数</h1><p>有2.5亿个整数(这2.5亿个整数存储在一个数组里面，至于数组是放在外存还是内存，没有进一步具体说明)；<br>要求找出这2.5亿个数字里面， 不重复的数字的个数 ； 另外，可用的内存限定为600M； </p><p>用一个bit表示一个数是否存在，32bit中无符号整数有4G个，共需4G bits，每个字节8 bits，需要4G/8 = 512M字节；申请512M内存，作为一个数是否存在的标记flag，全清0；申请另外一组bit作为计数器count，全清0；</p><h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p><code>volatile</code>直译为易失性的，意在声明某变量有可能被编译器未知的因素更改，如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，<strong>编译器对访问该变量的代码就不再进行优化</strong>。例如：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitForSemaphore</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">uint16_t</span>* semPtr = WELL_KNOWN_SEM_ADDR;<span class="hljs-comment">/*well known address to my semaphore*/</span>   <span class="hljs-keyword">while</span> ((*semPtr) != IS_OK_FOR_ME_TO_PROCEED);&#125;</code></pre></div><p>如果未进行易失性声明，优化编译器会把变量从内存装入CPU寄存器中， 即使其他线程对内存中的变量进行修改，当前线程只使用寄存器中的值，<code>while</code>循环将是一个死循环；加修饰字之后，编译器每次操作该变量时会从内存中真正取出。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> a = i;<span class="hljs-keyword">int</span> b = i;</code></pre></div><p><code>volatile</code>指出<code>i</code>是随时可能发生变化的，每次使用它的时候必须从<code>i</code>的地址中读取，因而编译器生成的汇编代码会重新从<code>i</code>的地址读取数据放在<code>b</code>中。而优化做法是，由于编译器发现两次读数据的代码之间的代码没有对<code>i</code>进行过操作，它会自动把上次读的数据放在 <code>b</code>中。而不是重新从<code>i</code>里面读。</p><p><strong>参考</strong></p><p><a href="https://stackoverflow.com/a/72576/16657286">https://stackoverflow.com/a/72576/16657286</a></p><p><a href="https://zhuanlan.zhihu.com/p/62060524">https://zhuanlan.zhihu.com/p/62060524</a></p><h1 id="常驻内存和共享内存"><a href="#常驻内存和共享内存" class="headerlink" title="常驻内存和共享内存"></a>常驻内存和共享内存</h1><ul><li>常驻内存：进程间切换时，操作系统会将数据从内存复制到磁盘上来释放一部分内存。然而，当一部分内存指定为<em>常驻</em>时，它不会与磁盘交换。使频繁访问的数据常驻在内存中可以减少访问该数据所需的磁盘 I/O 操作，如操作系统的中心部分和一些特殊程序，如日历和计算器。</li><li>共享内存是进程间通信中最简单的方式之一。共享内存允许两个或更多进程访问同一块内存，当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。</li></ul><h1 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h1><p>DNS （Domain Name System）的作用非常简单，就是根据域名查出IP地址。</p><p>客户端在上网的时候，需要设置：本机的IP地址、子网掩码、网关的IP地址、DNS服务器的IP地址。我们就是通过DNS服务器查得域名对应的IP地址。DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。</p><p>DNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询。</p><p><strong>域名的层级</strong></p><p>举例来说，<code>www.example.com</code>真正的域名是<code>www.example.com.root</code>，简写为<code>www.example.com.</code>。因为，根域名<code>.root</code>对于所有域名都是一样的，所以平时是省略的。</p><p>根域名的下一级，叫做”顶级域名”（top-level domain，缩写为TLD），比如<code>.com</code>、<code>.net</code>；再下一级叫做”次级域名”（second-level domain，缩写为SLD），比如<code>www.example.com</code>里面的<code>.example</code>，这一级域名是用户可以注册的；再下一级是主机名（host），比如<code>www.example.com</code>里面的<code>www</code>，又称为”三级域名”，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。</p><p>总结一下，域名的层级结构如下。</p><div class="code-wrapper"><pre><code class="hljs no">主机名.次级域名.顶级域名.根域名# 即host.sld.tld.root</code></pre></div><p><strong>DNS记录</strong></p><p>域名与IP之间的对应关系，称为”记录”。根据使用场景，”记录”可以分成不同的类型。</p><div class="code-wrapper"><pre><code class="hljs dns">（<span class="hljs-number">1</span>） <span class="hljs-keyword">A</span>：地址记录（Address），返回域名指向的IP地址。（<span class="hljs-number">2</span>） <span class="hljs-keyword">NS</span>：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。（<span class="hljs-number">3</span>）<span class="hljs-keyword">CNAME</span>：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转。</code></pre></div><p><strong>分级查询</strong></p><p>“分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址。每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。过程大致如下。</p><div class="code-wrapper"><pre><code class="hljs no">1. 从&quot;根域名服务器&quot;查到&quot;顶级域名服务器&quot;的NS记录和A记录（IP地址）2. 从&quot;顶级域名服务器&quot;查到&quot;次级域名服务器&quot;的NS记录和A记录（IP地址）3. 从&quot;次级域名服务器&quot;查出&quot;主机名&quot;的IP地址</code></pre></div><p>上面，”根域名服务器”的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面。</p><p><strong>参考</strong></p><p><a href="https://www.ruanyifeng.com/blog/2016/06/dns.html">https://www.ruanyifeng.com/blog/2016/06/dns.html</a></p><h1 id="进程的内存分布"><a href="#进程的内存分布" class="headerlink" title="进程的内存分布"></a>进程的内存分布</h1><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/面经1.png?raw=true" alt=""></p><p>从低地址到高地址，分别包括：</p><ol><li>文本段，也叫代码段，是对象文件或内存中程序的一部分，其中包含可执行指令。通常代码段是共享的，对于经常执行的程序，只有一个副本需要存储在内存中，代码段是只读的，以防止程序以外修改指令。</li><li>初始化的数据段，是程序的虚拟地址空间的一部分，它包含有程序员初始化的全局变量和静态变量，可以进一步划分为只读区域和读写区域。例如，C中的char=“hello world”的全局字符串，以及main(例如全局)之外的int debug=1这样的C语句。</li><li>未初始化的数据段，通常称为bss段，这个段的数据在程序开始之前有内核初始化为0，包含所有初始化为0和没有显示初始化的全局变量和静态变量，</li><li>堆，堆是动态内存分配通常发生的部分。堆是由程序员自己分配的（malloc kmalloc等）。堆区域由所有共享库和进程中动态加载的模块共享。</li><li>栈，存放临时变量，以及每次调用函数时调用栈。每当调用一个函数时，返回到的地址和关于调用者环境的某些信息的地址，比如一些机器寄存器，就会被保存在栈中。然后，新调用的函数在栈上分配空间，用于自动和临时变量。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac下使用GitHub+Hexo+Fluid搭建个人博客</title>
    <link href="/2021/08/03/blog-init/"/>
    <url>/2021/08/03/blog-init/</url>
    
    <content type="html"><![CDATA[<h1 id="安装：Git、node-js、-hexo"><a href="#安装：Git、node-js、-hexo" class="headerlink" title="安装：Git、node.js、 hexo"></a>安装：Git、node.js、 hexo</h1><ol><li><p>安装Homebrew</p></li><li><p>安装node.js</p><div class="code-wrapper"><pre><code class="hljs crmsh">brew install <span class="hljs-keyword">node</span><span class="hljs-title"></span></code></pre></div></li><li><p>安装git</p><ul><li><p>一种方法是安装Xcode</p></li><li><p>另一种方法是</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>git</code></pre></div></li></ul></li><li><p>使用 npm 安装 hexo</p><div class="code-wrapper"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span></code></pre></div></li></ol><h1 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h1><ol><li><p>在某位置新建blogs文件夹，如<code>～/Documents/blogs</code>，并<code>cd</code>入该文件夹</p></li><li><p>博客初始化，这一步会在<code>blogs</code>中生成一些配置文件</p><div class="code-wrapper"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span></code></pre></div></li><li><p>进行本地预览</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span></code></pre></div></li><li><p>在<code>http://localhost:4000</code>进行预览，看到HEXO的<code>hello world</code>界面即为成功</p></li></ol><h1 id="添加SSH-Key到github"><a href="#添加SSH-Key到github" class="headerlink" title="添加SSH Key到github"></a>添加SSH Key到github</h1><ul><li><code>Enter file in which to save the key</code>时直接按回车，即在默认位置生成ssh文件，即<code>/Users/xxx/.ssh/id_rsa.pub</code></li><li><code>Enter passphrase</code>时直接回车即不需要密码，如设置密码，该密码为push时需要的密码，与github账户密码等无关</li></ul><div class="code-wrapper"><pre><code class="hljs gradle">% git config --global user.name <span class="hljs-string">&quot;github账户名，大小写敏感&quot;</span>                   % git config --global user.email <span class="hljs-string">&quot;github账户邮箱&quot;</span>% ssh-keygen -t rsa -C <span class="hljs-string">&quot;github账户邮箱&quot;</span>Generating <span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span> rsa key pair.Enter <span class="hljs-keyword">file</span> in which to save the key (<span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/.ssh/i</span>d_rsa): Created directory <span class="hljs-string">&#x27;/Users/lihan/.ssh&#x27;</span>.Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase): Enter same passphrase again: Your identification has been saved in <span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/.ssh/i</span>d_rsa.Your <span class="hljs-keyword">public</span> key has been saved in <span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub.</code></pre></div><p>生成文件之后，复制<code>id_rsa.pub</code>中的内容，这就是需要的key；登陆github -&gt; setting -&gt; SSH and GPG keys -&gt; New SSH key，将key复制粘贴，Title可以取名为设备名</p><h1 id="本地博客关联到Github主页"><a href="#本地博客关联到Github主页" class="headerlink" title="本地博客关联到Github主页"></a>本地博客关联到Github主页</h1><ol><li><p>登录Github并且创建一个名字为 <code>username.github.io</code> 的仓库，如<code>HerloConnell.github.io</code>，选择<code>Public</code></p></li><li><p>修改<code>blogs/_config.yml</code>的<code>deploy</code>，注意这里使用的是分支master</p><p><strong>在8.13号以后git需要使用令牌，repo设置稍有改动，具体见错误2</strong></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/HerloConnell/HerloConnell.github.io.git</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre></div></li><li><p>将博客push到GitHub</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><span class="hljs-attribute">hexo d</span></code></pre></div></li><li><p>在该仓库的<code>settings</code>中选择<code>GitHub Pages</code>,点击<code>heck it out here!</code>，显示</p><div class="code-wrapper"><pre><code class="hljs delphi">Your site <span class="hljs-keyword">is</span> <span class="hljs-keyword">published</span> at https:<span class="hljs-comment">//herloconnell.github.io/</span></code></pre></div><p>在<code>Source</code>处选择<code>Branch:master</code></p></li><li><p>再次执行下面的代码，此时应该可以在<code>https://herloconnell.github.io/</code>看到Hexo界面</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><span class="hljs-attribute">hexo d</span></code></pre></div></li></ol><h1 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h1><div class="code-wrapper"><pre><code class="hljs axapta">hexo n <span class="hljs-string">&quot;博客名称&quot;</span>  =&gt; hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;博客名称&quot;</span>   <span class="hljs-meta">#这两个都是创建新文章，前者是简写模式</span>hexo p  =&gt; hexo publishhexo g  =&gt; hexo generate  <span class="hljs-meta">#生成</span>hexo s  =&gt; hexo <span class="hljs-keyword">server</span>  <span class="hljs-meta">#启动服务预览</span>hexo d  =&gt; hexo deploy  <span class="hljs-meta">#部署  </span>hexo <span class="hljs-keyword">server</span>   <span class="hljs-meta">#Hexo 会监视文件变动并自动更新，无须重启服务器。</span>hexo <span class="hljs-keyword">server</span> -s   <span class="hljs-meta">#静态模式</span>hexo <span class="hljs-keyword">server</span> -p <span class="hljs-number">5000</span>   <span class="hljs-meta">#更改端口</span>hexo <span class="hljs-keyword">server</span> -i <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>   <span class="hljs-meta">#自定义IP</span>hexo clean   <span class="hljs-meta">#清除缓存，网页正常情况下可以忽略此条命令</span>hexo g   <span class="hljs-meta">#生成静态网页</span>hexo d   <span class="hljs-meta">#开始部署</span></code></pre></div><h1 id="Fluid主题"><a href="#Fluid主题" class="headerlink" title="Fluid主题"></a>Fluid主题</h1><p><a href="https://hexo.io/themes/">hexo主题网站</a>，<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a></p><ol><li><p>在<code>/blogs/themes</code>中</p><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/fluid-dev/hexo-theme-fluid.git</code></pre></div></li><li><p>将<code>hexo-theme-fluid</code>文件夹更名为<code>fluid</code>，并修改hexo的<code>_config.yml</code></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span></code></pre></div></li><li><p>参考<code>Fluid</code>主题配置进行配置，如配置<code>Latex</code>支持等（注：<code>Latex</code>需要在文章 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a>里指定 <code>math: true</code> 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度）</p></li></ol><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p><strong>错误一：443</strong></p><div class="code-wrapper"><pre><code class="hljs bash">fatal unable to access https://github.com LibreSSL SSL_connect SSL_ERROR_SYSCALL <span class="hljs-keyword">in</span> connection to github.com 443</code></pre></div><p>科学上网的换个节点或者多提交几次即可</p><p><strong>错误二：403</strong></p><div class="code-wrapper"><pre><code class="hljs bash">remote: Support <span class="hljs-keyword">for</span> password authentication was removed on August 13, 2021. Please use a personal access token instead.remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ <span class="hljs-keyword">for</span> more information.fatal: unable to access <span class="hljs-string">&#x27;https://github.com/HerloConnell/HerloConnell.github.io.git/&#x27;</span>: The requested URL returned error: 403</code></pre></div><p>2021年8月13后 GitHub 不能再用密码pull/push 需要使用令牌。</p><ul><li><p>进入 Github —&gt; Settings —&gt; Developer settings —&gt; Personal access tokens获得一个token，这里作用域我点的全选。</p></li><li><p>修改<code>config</code></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://&lt;Token&gt;@github.com/HerloConnell/HerloConnell.github.io.git</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂七杂八</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
