<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图解计算机网络笔记</title>
    <link href="/2021/08/07/%E5%9B%BE%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/07/%E5%9B%BE%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP-篇"><a href="#HTTP-篇" class="headerlink" title="HTTP 篇"></a>HTTP 篇</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><p>HTTP 是超文本传输协议，也就是<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p></li><li><p><strong>常见的状态码</strong></p><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记3.png?raw=true" alt=""></p></li><li><p><strong>http常⻅字段</strong></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">客户端发送请求时：</span><span class="hljs-attr">Host:</span> <span class="hljs-string">www.A.com</span><span class="hljs-string">指定服务器域名</span><span class="hljs-attr">Connection:</span> <span class="hljs-string">keep-alive</span><span class="hljs-string">最常用于客户端要求服务器使用</span> <span class="hljs-string">TCP</span> <span class="hljs-string">持久连接，以便其他请求复用</span><span class="hljs-attr">Accept:</span> <span class="hljs-string">*/*</span><span class="hljs-string">客户端声明自己可以接受哪些数据格式，*/*表示接受任何格式</span><span class="hljs-attr">Accept-Encoding:</span> <span class="hljs-string">gzip,</span> <span class="hljs-string">deflate</span><span class="hljs-string">说明自己可以接受哪些压缩方法</span><span class="hljs-string">服务器响应请求时：</span><span class="hljs-attr">Content-Length:</span> <span class="hljs-number">1000</span><span class="hljs-string">表明本次回应的数据⻓度1000字节</span><span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/html;</span> <span class="hljs-string">charset=utf-8</span><span class="hljs-string">服务器表明自己发送的数据格式，发送的是网⻚，编码为UTF-8</span><span class="hljs-attr">Content-Encoding:</span> <span class="hljs-string">gzip</span> <span class="hljs-string">表示服务器返回的数据使用gzip压缩格式</span></code></pre></div></li><li><p><strong>GET与POST</strong></p><p>Get请求从服务器获取资源；</p><p>POST向 <strong>URI</strong> 指定的资源提交数据，数据就放在报文的 body 里，服务器响应代表处理结果。</p><p><strong>安全</strong>指请求方法不会破坏服务器上的资源， <strong>幂等</strong>指多次执行相同的操作，结果都是相同的。</p><p>GET方法就是安全且幂等的，POST是不安全的不幂等的。</p></li></ol><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p class="note note-primary">  <b>HTTP/1.1特点</b></p><p><strong>简单</strong>：基本的报文格式就是 header + body ，头部信息也是 key-value 简单文本的形式；</p><p><strong>灵活</strong>：各类请求方法、URI/URL、状态码、头字段等都允许开发人员自定义和扩充，HTTP 工作在应用层，下层可以随意变化；</p><p><strong>无状态</strong>：服务器不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，对于关联性操作可以使用 Cookie技术解决；</p><p><strong>明文传输</strong>：在传输过程中的信息，是可方便阅读的，这种特性同时也有很大的安全隐患。</p><p class="note note-primary">  <b>HTTP/1.1如何优化</b></p><ol><li><p>减少HTTP请求次数</p><p><span class="label label-primary">缓存</span></p><p>服务器在返回资源的时候，同时返回一个预估的过期时间，客户端以URL作为key，资源作为value的形式存储在本地。在此访问同URL时，先查询本地磁盘，如果存在：若未过期，直接返回资源；否则，再次发起请求，并附带本地过期资源的摘要，若服务器发现资源未变动，直接返回不含有包体的 <strong>304 Not Modified</strong> 响应，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时。</p><p><span class="label label-primary">重定向服务交给代理服务器</span></p><p><span class="label label-primary">合并请求</span></p><p>如将小图片合为一张大图片，js、css等小资源合为一个文件。以一个大资源的请求替换多个小资源的请求。 但当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件，带来了额外的网络消耗。</p><p><span class="label label-primary">延迟发送请求 </span></p><p>按需获取。请求网⻚的时候只获取当前用户所看到的⻚面资源，当用户向下滑动⻚面的时候，再向服务器获取接下来的资源。</p></li><li><p>减少HTTP响应数据大小</p><p><span class="label label-primary">无损压缩、有损压缩</span></p></li></ol><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>加密算法分为以下两种：</p><p><span class="label label-primary"><b>对称加密</b></span></p><ul><li>甲方选择某一种加密规则，对信息进行加密；乙方使用同一种规则，对信息进行解密；</li><li>加密和解密使用同样规则（简称”<strong>密钥</strong>“）。</li></ul><p>甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。</p><p>后来，人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。</p><p><span class="label label-primary"><b>不对称加密：公钥加密法</b></span></p><ul><li>乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的；甲方获取乙方的公钥，然后用它对信息加密。乙方得到加密后的信息，用私钥解密；</li><li>公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立；</li><li>所有的（公钥, 私钥）对都是不同的；</li><li><strong>用公钥可以解开私钥加密的信息，反之亦成立</strong>；</li><li>同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的；</li><li>在双钥体系中，<strong>公钥用来加密信息，私钥用来数字签名</strong>。</li></ul><p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>不对称加密过程中，双方的通信是建立在公钥可信的基础上的：</p><ol><li>B对数据进行Hash生成<strong>摘要</strong>后，使用私钥对摘要进行加密，生成<strong>数字签名</strong>；B将数据和数字签名一同发给A；</li><li>A对数据进行相同的Hash，并对数字签名使用B的公钥解密；如果解密结果与Hash结果相同，则确认为B发出。</li></ol><p>如果一开始A拿到的公钥就是假的话，那么B后来发出的任何内容A均无法识别。问题在于A获取公钥的过程依然是明文传输的，为此提出数字证书的方法，通过可信的第三方（CA）对公钥进行签名，保证B的公钥通过可信的方式传递给A：</p><ol><li>CA使用私钥对B的公钥及相关信息如证书的颁布机构、有效期、持有者进行签名，生成数字证书；</li><li>B将数据，数字签名，数字证书一同发送给A；</li><li>CA的公钥也是需要使用证书来分发的，所以 A的电脑必须安装CA的证书，证书里包含CA的公钥。</li><li>A用CA的公钥解开数字证书，验证证书的可信性；从证书拿到B真实的公钥，验证”数字签名”是否真的是B签的。</li></ol><p><strong>为什么先进行摘要再进行签名？</strong></p><p>原数据过大，加密算法耗时。</p><h3 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h3><p>HTTP 由于是明文传输，所谓的明文，就是说客户端与服务端通信的信息都是肉眼可⻅的，随意使用一个抓包工具都可以截获通信的内容。<br>所以安全上存在以下三个⻛险</p><ul><li><strong>窃听风险</strong>：第三方可以获知通信内容；</li><li><strong>篡改风险</strong>：第三方可以修改通信内容；</li><li><strong>冒充风险</strong>：第三方可以冒充他人身份参与通信。</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加入了SSL/TLS协议，来解决上述的⻛险。</p><ul><li>所有信息都是<strong>加密传播</strong>，第三方无法窃听；</li><li>具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现；</li><li>配备<strong>身份证书</strong>，防止身份被冒充。</li></ul><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记1.png?raw=true" alt=""></p><p>SSL/TLS协议的基本思路是采用<a href="https://en.wikipedia.org/wiki/Public-key_cryptography">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p>但是，这里有两个问题。</p><ol><li><p>如何保证公钥不被篡改？</p><p>将公钥放在<a href="https://en.wikipedia.org/wiki/Digital_certificate">数字证书（CA）</a>中。只要证书是可信的，公钥就是可信的。</p></li><li><p>公钥加密计算量太大，如何减少耗用的时间？</p><p>采用<strong>混合加密</strong>。每一次对话，客户端和服务器端都生成一个”<strong>对话密钥</strong>“，用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p></li></ol><p>因此，SSL/TLS协议的基本过程是这样的：</p><ul><li><p>客户端向服务器端索要并验证公钥；</p></li><li><p>双方协商生成”对话密钥”；</p></li><li><p>双方采用”对话密钥”进行加密通信；</p></li></ul><p>上面过程的前两步，又称为”握手阶段”。</p><h3 id="SSL-TSL握手"><a href="#SSL-TSL握手" class="headerlink" title="SSL/TSL握手"></a>SSL/TSL握手</h3><p>基于RSA加密的握手过程，也是基础的SSL/TSL握手过程。</p><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记2.png?raw=true" alt=""></p><p><strong>1. 客户端发出请求（ClientHello）</strong></p><p>客户端向服务器发出加密通信的请求，称为ClientHello请求，客户端主要向服务器提供以下信息：</p><p class="note note-secondary">  （1）支持的协议版本，比如TLS 1.0版。  <br>  （2）一个客户端生成的随机数Client random，稍后用于生成"对话密钥"。  <br>  （3）支持的加密方法，比如RSA公钥加密。  <br>  （4）支持的压缩方法。</p><p><strong>2. 服务器回应（SeverHello）</strong></p><p>服务器的回应包含以下内容：</p><p class="note note-secondary">  （1）确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。  <br>  （2）一个服务器生成的随机数Server random，稍后用于生成"对话密钥"。  <br>  （3）确认使用的加密方法，比如RSA公钥加密。  <br>  （4）服务器证书。</p><p><strong>3. 客户端回应</strong></p><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p><p class="note note-secondary">  （1）一个随机数。该随机数用服务器公钥加密，防止被窃听。  <br>  （2）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。  <br>  （3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p><p> 此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p><p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p><p>值得注意的是，该过程之前的阶段均为明文传输；而pre-master key使用服务器公钥加密，之后客户端与服务器端均生成会话密钥，数据传输均为加密传输。</p><p><strong>4. 服务器的最后回应</strong></p><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p><p class="note note-secondary">  （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。  <br>  （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p><p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p><p>使用 RSA密钥协商算法的最大问题是不支持前向保密。整个握手阶段都不加密（也没法加密），都是明文的。如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。所以一旦服务端的私钥泄漏 了，过去被第三方截获的所有 TLS 通讯密文都会被破解。所以目前使用较多的为<strong>ECDHE加密法</strong>。</p><h3 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h3><p><strong>离散对数</strong></p><p>假定 a, p 均是素数，下面两个集合相等，证明过程请参考 <a href="http://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0133354695">Cryptography and Network Security</a> 第八章：</p><div class="code-wrapper"><pre><code class="hljs no">&#123; a^1 mod p, a^2 mod p, ..., a^(p-1) mod p &#125; = &#123;1, 2, ... , p-1 &#125;   &#123;&#125; 表示集合</code></pre></div><p>上述式子可概括成以下三点，对于 1 &lt;= x,y &lt;= p - 1，有：</p><ul><li>a^x mod p 一定属于 {1, 2, …, p -1 }</li><li>如果 x != y，则 a^x mod p != a^y mod p</li><li>对于 1 &lt;= b &lt;= p - 1，一定存在唯一的 1 &lt;= x &lt;= p-1，使得 b = a^x mod p</li></ul><p>第三点在求解上有这么一个特点：已知 x 求 b 非常容易，已知 b 求 x 非常困难，特别当 p 很大时，求解的复杂度非常高，所以它又被称为离散对数问题 (<a href="https://en.wikipedia.org/wiki/Discrete_logarithm">Discrete logarithm</a>)，它是 DH 算法能够安全交换密钥的基础</p><p><strong>求模公式</strong></p><p>假设 q 为素数，对于正整数 a,x,y，有：</p><div class="code-wrapper"><pre><code class="hljs no">(a^x mod p)^y mod p = a^(xy) mod p</code></pre></div><p>证明如下：</p><div class="code-wrapper"><pre><code class="hljs no">令 a^x = mp + n， 其中 m, n 为自然数， 0 &lt;= n &lt; p，则有C = (a^x mod p)^y mod p  = ((mp + n) mod p)^y mod p  = n^y mod p  = (mp +n)^y mod p  = a^(xy) mod p</code></pre></div><p><strong>Deffie-Hellman 算法</strong></p><ol><li>首先 A, B 共同选取 p 和 a 两个素数，p 和 a 均公开；</li><li>之后 A 选择一个自然数 Xa &lt; p，计算出 Ya = a^Xa mod p，Xa 保密，Ya 公开；</li><li>同理，B 选择 Xb &lt; p 并计算出 Yb = a^Xb mod p，其中 Xb 保密，Yb 公开；</li><li>A 用 Yb 和 Xa 计算出密钥 K = Yb^Xa mod p，而 B 用 Ya 和 Xb 计算密钥 K = Ya^Xb mod p。</li></ol><p>流程如下：</p><div class="code-wrapper"><pre><code class="hljs no">+-------------------------------------------------------------------+|                    Global Pulic Elements                          ||                                                                   ||       p                               prime number                ||       a                               prime number, a &lt; p         |+-------------------------------------------------------------------++-------------------------------------------------------------------+|                    User A Key Generation                          ||                                                                   ||       Select private Xa               Xa &lt; p                      ||       Calculate public Ya             Ya = a^Xa mod p             |+-------------------------------------------------------------------++-------------------------------------------------------------------+|                    User B Key Generation                          ||                                                                   ||       Select private Xb               Xb &lt; p                      ||       Calculate public Yb             Yb = a^Xb mod p             |+-------------------------------------------------------------------++-------------------------------------------------------------------+|               Calculation of Secret Key by User A                 ||                                                                   ||       Secret Key K                    K = Yb^Xa mod p             |+-------------------------------------------------------------------++-------------------------------------------------------------------+|               Calculation of Secret Key by User B                 ||                                                                   ||       Secret Key K                    K = Ya^Xb mod p             |+-------------------------------------------------------------------+</code></pre></div><p>下面证明，A 和 B 计算出来的密钥 K 相同。</p><div class="code-wrapper"><pre><code class="hljs no">K = Yb^Xa mod p  = (a^Xb mod p)^Xa mod p  = a^(Xa * Xb) mod p          根据上述求模公式  = (a^Xa mod p)^Xb mod p  = Ya^Xb mod p</code></pre></div><p>上面一共出现了 a, p, Xa, Ya, Xb, Yb, K 共 7 个数，其中：</p><ul><li>公开的数：a, p, Ya, Yb</li><li>非公开数：Xa, Xb, K</li></ul><p>通常情况下，a 一般为 2 或 5，而 p 的取值非常大，至少几百位，Xa 和 Xb 的取值也非常大，其复杂度至少为 <a href="https://en.wikipedia.org/wiki/Pollard&#39;s_rho_algorithm_for_logarithms">O(p^0.5)</a>。对于攻击者来说，已知 Ya，Xa 的求解非常困难，同理 Xb 的求解也很困难，所以攻击者难以求出 K，所以 DH 能够保证通信双方在<strong>透明</strong>的信道中安全的交换密钥。</p><p>DH 算法主要实现方法为<strong>DHE 算法</strong>，DHE 算法让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，E 全称是 ephemeral（临时性的）。这样就保证了 <strong>前向安全</strong>，即使曾经的通信过程被破解，不会影响现在的通信的安全性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">阮一峰.RSA算法原理（一）</a></p><p><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">阮一峰.SSL/TLS协议运行机制的概述</a></p><p><a href="https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">阮一峰.图解SSL/TLS协议</a></p><p><a href="https://juejin.cn/post/6895624327896432654#heading-9">洛禹Keith.TLS 详解握手流程</a></p><p><a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">小林coding.图解 HTTP 常见的面试题</a></p><p><a href="https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">阮一峰.数字签名是什么</a></p><p><a href="http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html">阮一峰.密码学笔记</a></p><p><a href="https://segmentfault.com/a/1190000024523772">编程指北.加密、数字签名和数字证书</a></p><p><a href="http://wsfdl.com/algorithm/2016/02/04/理解Diffie-Hellman密钥交换算法.html">koala bear.理解 Deffie-Hellman 密钥交换算法</a></p><h1 id="TCP-篇"><a href="#TCP-篇" class="headerlink" title="TCP 篇"></a>TCP 篇</h1><p>TCP是<code>面向连接</code>的、<code>可靠</code>的、<code>基于字节流</code>的传输层通信协议。</p><h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h2><p>在介绍三次握手，四次挥手的过程之前，需要了解TCP头部的一些知识</p><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记4.png?raw=true" alt=""></p><ul><li><code>源端口</code>和目的端口：确定主机中的进程；</li><li>序号(seq)：报文段中的的第一个数据字节在数据流中的序号，主要用来解决网络报乱序的问题；</li><li>确认号(ack_seq)：所期望收到的下一个数据包的序号；</li><li>ACK：1有效，表示已经收到数据包</li><li>RST：1有效，连接复位请求</li><li>SYN：1有效，表示申请与接收方建立连接</li><li>FIN：1有效，表示申请与接收方断开连接</li></ul><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><blockquote><p>在Google Groups的<a href="https://groups.google.com/forum/#!forum/pongba">TopLanguage</a>中看到一帖讨论TCP“三次握手”觉得很有意思。贴主提出“<a href="https://groups.google.com/forum/#!topic/pongba/kF6O7-MFxM0/discussion">TCP建立连接为什么是三次握手？</a>”的问题，在众多回复中，有<a href="https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ">一条回复</a>写道：“这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”。</p></blockquote><p>网络中A与B要建立TCP连接，可以分为以下四步：</p><div class="code-wrapper"><pre><code class="hljs no">（1）A请求向B发送消息（2）B向A表示同意（3）B请求向A发送消息（4）A向B表示同意</code></pre></div><p>可以发现，由于(2)(3)过程均为B向A发送消息，所以合为一次握手，实际上TCP建立连接只需要三次握手即可。</p><p>接下来介绍三次握手的具体过程</p><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记5.png?raw=true" alt=""></p><p class="note note-secondary">  （1）A发送SYN=1，seq初始化为随机值X的连接请求报文段，之后进入SYN_SEND状态；  <br>  （2）收到连接请求前，B可以认为处于LISTEN阶段；收到连接请求后，B向A发送一个响应+请求报文段，置ACK=1，SYN=1，ack_seq=X+1，seq初始化为随机值Y，B进入SYN_RCVD状态；  <br>  （3）A响应B的连接请求，向B发送一个ACK=1的报文段，置seq=X+第一次握手报文长度1，ack_seq=Y，之后A进入ESTABLISHED状态；  <br>  （4）B收到A响应后同样进入ESTABLISHED状态，连接建立完成。</p><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记6.png?raw=true" alt=""></p><p>挥手过程，A与B断开连接之后，B可能还会有需要发个A的数据，不能立刻断开连接，需要有一个CLOSE_WAIT的过程，不能合为三次。</p><p class="note note-secondary">  （1）A将FIN置为1，ACK置为1，seq设置为X=上一次对方传送过来的ack_seq，ack_seq设置为Y=为上一次对方传过来的seq+1。将数据发送至B，然后A进入FIN_WAIT_1状态；  <br>  （2）B收到了A发送的FIN报文段，向A回复，将ACK置为1，seq设置为Y，ack_seq设置为X+1。然后B进入CLOSE_WAIT状态，A收到B的回复后，进入FIN_WAIT_2状态；  <br>  （3）B再次向A发送报文，FIN置为1，ACK置为1，seq设置为Y，ack_seq设置为X+1，然后B进入LAST_ACK状态，A收到B的报文后，进入TIME_WAIT状态；  <br>  （4）A收到B发送的FIN报文段，向B回复，ACK置为1，seq设置为X+1，ack_seq设置为Y+1。然后A进入TIME_WAIT状态，B在收到报文后进入CLOSED状态。A在发送完报文等待了2MSL时间后进入CLOSED状态。</p><p><strong>为什么 TIME_WAIT 状态要等待 2MSL 之后才关闭连接</strong></p><ul><li>2MSL表示两个MSL的时长，MSL全称为Maximum Segment Life，表示TCP Segment 生存时间的限制。</li><li>为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST_ACK状态的B收不到对自己已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段。而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后A和B都正常进入到CLOSED状态。如果A在TIME_WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而也不会在发送一次确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。</li><li>使下一个新的连接中不会出现这种旧的连接请求报文段。A在发送完最后一个ACK报文段后，在经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。</li></ul><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.jiar.me/2017/08/11/TCP三次握手简介/">Jiar.TCP三次握手简介</a></p><p><a href="https://blog.jiar.me/2017/08/24/TCP四次挥手简介/">Jiar.TCP四次挥手简介</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经</title>
    <link href="/2021/08/06/%E9%9D%A2%E7%BB%8F/"/>
    <url>/2021/08/06/%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="C-C-static关键字作用"><a href="#C-C-static关键字作用" class="headerlink" title="C/C++ static关键字作用"></a>C/C++ static关键字作用</h1><ol><li><p>隐藏：当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p></li><li><p>全局生命周期：存储在静态数据区的变量会在程序刚开始运行时就完成唯一的一次初始化。 共有两种变量存储在静态存储区：全局变量和static变量，与全局变量相比，static可以控制变量的可见范围。</p></li><li><p>变量默认初始化为0：在静态数据区，内存中所有的字节默认值都是0x00，所以全局变量也具备这一属性。</p></li><li><p>C++中的类成员声明static</p><ul><li>static修饰的变量或函数是属于类的，所有对象只有一份拷贝。 因此，不能将静态函数设为虚函数。  </li><li>静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）  </li></ul></li></ol><h1 id="vector是如何扩容的"><a href="#vector是如何扩容的" class="headerlink" title="vector是如何扩容的"></a>vector是如何扩容的</h1><p>往vector中添加元素时，如果空间不够将会导致扩容。vector有两个属性：size和capacity。size表示已经使用的数据容量，capacity表示数组的实际容量，包含已使用的和未使用的。</p><p>vector扩容规则：</p><ol><li>当数组大小不够容纳新增元素时，开辟更大的内存空间，把旧空间上的数据复制过来，然后在新空间中继续增加。</li><li>新的更大的内存空间，一般是当前空间的1.5倍或者2倍，这个1.5或者2被称为扩容因子，不同系统实现扩容因子也不同。</li></ol><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><p>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在统一作用域中。</p><p>覆盖：子类继承父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写。</p><p>重写：</p><p>（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。<br>（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</p><h1 id="2-5亿个数求不重复数"><a href="#2-5亿个数求不重复数" class="headerlink" title="2.5亿个数求不重复数"></a>2.5亿个数求不重复数</h1><p>有2.5亿个整数(这2.5亿个整数存储在一个数组里面，至于数组是放在外存还是内存，没有进一步具体说明)；<br>要求找出这2.5亿个数字里面， 不重复的数字的个数 ； 另外，可用的内存限定为600M； </p><p>用一个bit表示一个数是否存在，32bit中无符号整数有4G个，共需4G bits，每个字节8 bits，需要4G/8 = 512M字节；申请512M内存，作为一个数是否存在的标记flag，全清0；申请另外一组bit作为计数器count，全清0；</p><h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p><code>volatile</code>直译为易失性的，意在声明某变量有可能被编译器未知的因素更改，如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，<strong>编译器对访问该变量的代码就不再进行优化</strong>。例如：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitForSemaphore</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">uint16_t</span>* semPtr = WELL_KNOWN_SEM_ADDR;<span class="hljs-comment">/*well known address to my semaphore*/</span>   <span class="hljs-keyword">while</span> ((*semPtr) != IS_OK_FOR_ME_TO_PROCEED);&#125;</code></pre></div><p>如果未进行易失性声明，优化编译器会把变量从内存装入CPU寄存器中， 即使其他线程对内存中的变量进行修改，当前线程只使用寄存器中的值，<code>while</code>循环将是一个死循环；加修饰字之后，编译器每次操作该变量时会从内存中真正取出。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> a = i;<span class="hljs-keyword">int</span> b = i;</code></pre></div><p><code>volatile</code>指出<code>i</code>是随时可能发生变化的，每次使用它的时候必须从<code>i</code>的地址中读取，因而编译器生成的汇编代码会重新从<code>i</code>的地址读取数据放在<code>b</code>中。而优化做法是，由于编译器发现两次读数据的代码之间的代码没有对<code>i</code>进行过操作，它会自动把上次读的数据放在 <code>b</code>中。而不是重新从<code>i</code>里面读。</p><p><strong>参考</strong></p><p><a href="https://stackoverflow.com/a/72576/16657286">https://stackoverflow.com/a/72576/16657286</a></p><p><a href="https://zhuanlan.zhihu.com/p/62060524">https://zhuanlan.zhihu.com/p/62060524</a></p><h1 id="常驻内存和共享内存"><a href="#常驻内存和共享内存" class="headerlink" title="常驻内存和共享内存"></a>常驻内存和共享内存</h1><ul><li>常驻内存：进程间切换时，操作系统会将数据从内存复制到磁盘上来释放一部分内存。然而，当一部分内存指定为<em>常驻</em>时，它不会与磁盘交换。使频繁访问的数据常驻在内存中可以减少访问该数据所需的磁盘 I/O 操作，如操作系统的中心部分和一些特殊程序，如日历和计算器。</li><li>共享内存是进程间通信中最简单的方式之一。共享内存允许两个或更多进程访问同一块内存，当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。</li></ul><h1 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h1><p>DNS （Domain Name System）的作用非常简单，就是根据域名查出IP地址。</p><p>客户端在上网的时候，需要设置：本机的IP地址、子网掩码、网关的IP地址、DNS服务器的IP地址。我们就是通过DNS服务器查得域名对应的IP地址。DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。</p><p>DNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询。</p><p><strong>域名的层级</strong></p><p>举例来说，<code>www.example.com</code>真正的域名是<code>www.example.com.root</code>，简写为<code>www.example.com.</code>。因为，根域名<code>.root</code>对于所有域名都是一样的，所以平时是省略的。</p><p>根域名的下一级，叫做”顶级域名”（top-level domain，缩写为TLD），比如<code>.com</code>、<code>.net</code>；再下一级叫做”次级域名”（second-level domain，缩写为SLD），比如<code>www.example.com</code>里面的<code>.example</code>，这一级域名是用户可以注册的；再下一级是主机名（host），比如<code>www.example.com</code>里面的<code>www</code>，又称为”三级域名”，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。</p><p>总结一下，域名的层级结构如下。</p><div class="code-wrapper"><pre><code class="hljs no">主机名.次级域名.顶级域名.根域名# 即host.sld.tld.root</code></pre></div><p><strong>DNS记录</strong></p><p>域名与IP之间的对应关系，称为”记录”。根据使用场景，”记录”可以分成不同的类型。</p><div class="code-wrapper"><pre><code class="hljs dns">（<span class="hljs-number">1</span>） <span class="hljs-keyword">A</span>：地址记录（Address），返回域名指向的IP地址。（<span class="hljs-number">2</span>） <span class="hljs-keyword">NS</span>：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。（<span class="hljs-number">3</span>）<span class="hljs-keyword">CNAME</span>：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转。</code></pre></div><p><strong>分级查询</strong></p><p>“分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址。每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。过程大致如下。</p><div class="code-wrapper"><pre><code class="hljs no">1. 从&quot;根域名服务器&quot;查到&quot;顶级域名服务器&quot;的NS记录和A记录（IP地址）2. 从&quot;顶级域名服务器&quot;查到&quot;次级域名服务器&quot;的NS记录和A记录（IP地址）3. 从&quot;次级域名服务器&quot;查出&quot;主机名&quot;的IP地址</code></pre></div><p>上面，”根域名服务器”的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面。</p><p><strong>参考</strong></p><p><a href="https://www.ruanyifeng.com/blog/2016/06/dns.html">https://www.ruanyifeng.com/blog/2016/06/dns.html</a></p><h1 id="进程的内存分布"><a href="#进程的内存分布" class="headerlink" title="进程的内存分布"></a>进程的内存分布</h1><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/面经1.png?raw=true" alt=""></p><p>从低地址到高地址，分别包括：</p><ol><li>文本段，也叫代码段，是对象文件或内存中程序的一部分，其中包含可执行指令。通常代码段是共享的，对于经常执行的程序，只有一个副本需要存储在内存中，代码段是只读的，以防止程序以外修改指令。</li><li>初始化的数据段，是程序的虚拟地址空间的一部分，它包含有程序员初始化的全局变量和静态变量，可以进一步划分为只读区域和读写区域。例如，C中的char=“hello world”的全局字符串，以及main(例如全局)之外的int debug=1这样的C语句。</li><li>未初始化的数据段，通常称为bss段，这个段的数据在程序开始之前有内核初始化为0，包含所有初始化为0和没有显示初始化的全局变量和静态变量，</li><li>堆，堆是动态内存分配通常发生的部分。堆是由程序员自己分配的（malloc kmalloc等）。堆区域由所有共享库和进程中动态加载的模块共享。</li><li>栈，存放临时变量，以及每次调用函数时调用栈。每当调用一个函数时，返回到的地址和关于调用者环境的某些信息的地址，比如一些机器寄存器，就会被保存在栈中。然后，新调用的函数在栈上分配空间，用于自动和临时变量。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac下使用GitHub+Hexo+Fluid搭建个人博客</title>
    <link href="/2021/08/03/blog-init/"/>
    <url>/2021/08/03/blog-init/</url>
    
    <content type="html"><![CDATA[<h1 id="安装：Git、node-js、-hexo"><a href="#安装：Git、node-js、-hexo" class="headerlink" title="安装：Git、node.js、 hexo"></a>安装：Git、node.js、 hexo</h1><ol><li><p>安装Homebrew</p></li><li><p>安装node.js</p><div class="code-wrapper"><pre><code class="hljs crmsh">brew install <span class="hljs-keyword">node</span><span class="hljs-title"></span></code></pre></div></li><li><p>安装git</p><ul><li><p>一种方法是安装Xcode</p></li><li><p>另一种方法是</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>git</code></pre></div></li></ul></li><li><p>使用 npm 安装 hexo</p><div class="code-wrapper"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span></code></pre></div></li></ol><h1 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h1><ol><li><p>在某位置新建blogs文件夹，如<code>～/Documents/blogs</code>，并<code>cd</code>入该文件夹</p></li><li><p>博客初始化，这一步会在<code>blogs</code>中生成一些配置文件</p><div class="code-wrapper"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span></code></pre></div></li><li><p>进行本地预览</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span></code></pre></div></li><li><p>在<code>http://localhost:4000</code>进行预览，看到HEXO的<code>hello world</code>界面即为成功</p></li></ol><h1 id="添加SSH-Key到github"><a href="#添加SSH-Key到github" class="headerlink" title="添加SSH Key到github"></a>添加SSH Key到github</h1><ul><li><code>Enter file in which to save the key</code>时直接按回车，即在默认位置生成ssh文件，即<code>/Users/xxx/.ssh/id_rsa.pub</code></li><li><code>Enter passphrase</code>时直接回车即不需要密码，如设置密码，该密码为push时需要的密码，与github账户密码等无关</li></ul><div class="code-wrapper"><pre><code class="hljs gradle">% git config --global user.name <span class="hljs-string">&quot;github账户名，大小写敏感&quot;</span>                   % git config --global user.email <span class="hljs-string">&quot;github账户邮箱&quot;</span>% ssh-keygen -t rsa -C <span class="hljs-string">&quot;github账户邮箱&quot;</span>Generating <span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span> rsa key pair.Enter <span class="hljs-keyword">file</span> in which to save the key (<span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/.ssh/i</span>d_rsa): Created directory <span class="hljs-string">&#x27;/Users/lihan/.ssh&#x27;</span>.Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase): Enter same passphrase again: Your identification has been saved in <span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/.ssh/i</span>d_rsa.Your <span class="hljs-keyword">public</span> key has been saved in <span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub.</code></pre></div><p>生成文件之后，复制<code>id_rsa.pub</code>中的内容，这就是需要的key；登陆github -&gt; setting -&gt; SSH and GPG keys -&gt; New SSH key，将key复制粘贴，Title可以取名为设备名</p><h1 id="本地博客关联到Github主页"><a href="#本地博客关联到Github主页" class="headerlink" title="本地博客关联到Github主页"></a>本地博客关联到Github主页</h1><ol><li><p>登录Github并且创建一个名字为 <code>username.github.io</code> 的仓库，如<code>HerloConnell.github.io</code>，选择<code>Public</code></p></li><li><p>修改<code>blogs/_config.yml</code>的<code>deploy</code>，注意这里使用的是分支master</p><p><strong>在8.13号以后git需要使用令牌，repo设置稍有改动，具体见错误2</strong></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/HerloConnell/HerloConnell.github.io.git</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre></div></li><li><p>将博客push到GitHub</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><span class="hljs-attribute">hexo d</span></code></pre></div></li><li><p>在该仓库的<code>settings</code>中选择<code>GitHub Pages</code>,点击<code>heck it out here!</code>，显示</p><div class="code-wrapper"><pre><code class="hljs delphi">Your site <span class="hljs-keyword">is</span> <span class="hljs-keyword">published</span> at https:<span class="hljs-comment">//herloconnell.github.io/</span></code></pre></div><p>在<code>Source</code>处选择<code>Branch:master</code></p></li><li><p>再次执行下面的代码，此时应该可以在<code>https://herloconnell.github.io/</code>看到Hexo界面</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><span class="hljs-attribute">hexo d</span></code></pre></div></li></ol><h1 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h1><div class="code-wrapper"><pre><code class="hljs axapta">hexo n <span class="hljs-string">&quot;博客名称&quot;</span>  =&gt; hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;博客名称&quot;</span>   <span class="hljs-meta">#这两个都是创建新文章，前者是简写模式</span>hexo p  =&gt; hexo publishhexo g  =&gt; hexo generate  <span class="hljs-meta">#生成</span>hexo s  =&gt; hexo <span class="hljs-keyword">server</span>  <span class="hljs-meta">#启动服务预览</span>hexo d  =&gt; hexo deploy  <span class="hljs-meta">#部署  </span>hexo <span class="hljs-keyword">server</span>   <span class="hljs-meta">#Hexo 会监视文件变动并自动更新，无须重启服务器。</span>hexo <span class="hljs-keyword">server</span> -s   <span class="hljs-meta">#静态模式</span>hexo <span class="hljs-keyword">server</span> -p <span class="hljs-number">5000</span>   <span class="hljs-meta">#更改端口</span>hexo <span class="hljs-keyword">server</span> -i <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>   <span class="hljs-meta">#自定义IP</span>hexo clean   <span class="hljs-meta">#清除缓存，网页正常情况下可以忽略此条命令</span>hexo g   <span class="hljs-meta">#生成静态网页</span>hexo d   <span class="hljs-meta">#开始部署</span></code></pre></div><h1 id="Fluid主题"><a href="#Fluid主题" class="headerlink" title="Fluid主题"></a>Fluid主题</h1><p><a href="https://hexo.io/themes/">hexo主题网站</a>，<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a></p><ol><li><p>在<code>/blogs/themes</code>中</p><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/fluid-dev/hexo-theme-fluid.git</code></pre></div></li><li><p>将<code>hexo-theme-fluid</code>文件夹更名为<code>fluid</code>，并修改hexo的<code>_config.yml</code></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span></code></pre></div></li><li><p>参考<code>Fluid</code>主题配置进行配置，如配置<code>Latex</code>支持等（注：<code>Latex</code>需要在文章 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter (opens new window)</a>里指定 <code>math: true</code> 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度）</p></li></ol><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p><strong>错误一：443</strong></p><div class="code-wrapper"><pre><code class="hljs bash">fatal unable to access https://github.com LibreSSL SSL_connect SSL_ERROR_SYSCALL <span class="hljs-keyword">in</span> connection to github.com 443</code></pre></div><p>科学上网的换个节点或者多提交几次即可</p><p><strong>错误二：403</strong></p><div class="code-wrapper"><pre><code class="hljs bash">remote: Support <span class="hljs-keyword">for</span> password authentication was removed on August 13, 2021. Please use a personal access token instead.remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ <span class="hljs-keyword">for</span> more information.fatal: unable to access <span class="hljs-string">&#x27;https://github.com/HerloConnell/HerloConnell.github.io.git/&#x27;</span>: The requested URL returned error: 403</code></pre></div><p>2021年8月13后 GitHub 不能再用密码pull/push 需要使用令牌。</p><ul><li><p>进入 Github —&gt; Settings —&gt; Developer settings —&gt; Personal access tokens获得一个token，这里作用域我点的全选。</p></li><li><p>修改<code>config</code></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://&lt;Token&gt;@github.com/HerloConnell/HerloConnell.github.io.git</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂七杂八</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
