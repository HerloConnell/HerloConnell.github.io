<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>RNN、LSTM、Seq2Seq、Pointer Network</title>
    <link href="/2021/10/04/RNN%E3%80%81LSTM%E3%80%81Seq2Seq%E3%80%81Pointer%20Network/"/>
    <url>/2021/10/04/RNN%E3%80%81LSTM%E3%80%81Seq2Seq%E3%80%81Pointer%20Network/</url>
    
    <content type="html"><![CDATA[<p>从基础的RNN网络结构开始，是如何一步步改进得到较为复杂的Pointer Network的。</p><h1 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h1><p>与传统的前向神经网络和卷积神经网络 (CNN) 不同，循环神经网络 (Recurrent Neural Networks，RNN)是一种擅于处理<strong>序列数据</strong>的模型，例如文本、时间序列、股票市场等。</p><p>对于序列数据，输入之间存在着先后顺序，如“我打车去商场” 和 “我去商场打车”，我们通常需要按照一定的顺序阅读句子才能理解句子的意思。</p><p>面对这种情况我们就需要用到循环神经网络了，每一时刻，RNN网络输入输出如下：</p><ul><li>$x_{t}$ 表示 t 时刻的输入向量(例如第 t 个单词的词向量)。</li><li>$h_t$ 表示 t 时刻的隐隐藏层向量 (包含了从开始一直到 t 时刻的相关信息)。</li><li>$y_t$ 表示 t 时刻的输出向量 (通常是预测的结果)。</li></ul><center>      <img height="40%" width="40%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化1.png?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图1 RNN神经元  </div> </center><p>在 RNN 中每一时刻都共用同一个神经元，将神经元展开之后如下图所示。</p><center>      <img height="60%" width="60%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化2.webp?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图2 RNN展开  </div> </center><p>在 RNN 中输入$x_{t}$只包含 t 时刻信息，不包含顺序信息；而 $h_t$           是根据$x_{t}$和$h_{t-1}$计算得到的，包含了历史信息与当前输入信息。</p><script type="math/tex; mode=display">h_{t} = \sigma (z_{t}) = \sigma (Ux_t + Wh_{t-1} + b) \\y_t = \sigma (Vh_t + c)</script><p>需要注意的是，对于任意时刻，所有的权值($W$,$U$,$V$)都相等，即“权值共享”，极大的减少参数量。</p><h1 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h1><p>RNN结构十分简单，但参数矩阵 U 和 W 的梯度均存在长期依赖，当面对一个长序列的时候，由于梯度消失与梯度爆炸，RNN难以发挥作用。1997年，<a href="http://www.bioinf.jku.at/publications/older/2604.pdf">Hochreiter &amp; Schmidhuber</a>提出一种RNN的变种LSTMs(Long Short Term Memory networks)，尝试解决长期依赖的问题。</p><blockquote><p>该部分的图出自Christopher Olah的<em>Understanding LSTM Networks</em><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Christopher Olah.Understanding LSTM Networks">[1]</span></a></sup></p></blockquote><p>在传统RNN中，循环单元结构简单，只有一层网络层，如单层tanh层。</p><center>      <img height="100%" width="100%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化3.png?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图3 拥有一层tanh层的RNN神经元  </div> </center><p>为了应对长期依赖，LSTM的循环单元结构更为复杂，他不再只有一层，取而代之的是多层神经网络层，他们各有不同的功能，且以特殊的方式互相连接在一起。</p><center>      <img height="100%" width="100%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化4.png?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图4 LSTMs的循环单元有更复杂的结构  </div> </center><p>上图中的一些符号含义如下</p><center>      <img height="80%" width="80%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化5.png?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图5 一些符号  </div> </center><p>带箭头的线代表向量的流动方向，分叉代表向量流向多个节点，合并代表向量以某种方式共同作用；黄色矩形代表神经网络层，拥有相应的权重、偏置、激活函数；粉色圆形代表一些向量运算，如按位乘等。</p><p>LSTMs的一个关键设计在于$C_t$的引入，他经过“遗忘门”、“输入门”的作用，最终在“输入门”影响最终的输入$h$。</p><center>      <img height="50%" width="50%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化6.png?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图6 cell state  </div> </center><p>另一关键设计是”门”的引入，他由sigmoid层与按位乘运算组成。LSTMs有三个门：<strong>遗忘门</strong>、<strong>输入门</strong>、<strong>输出门</strong>，我们来逐步了解他们是如何起作用的。</p><center>      <img height="20%" width="20%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化7.png?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图7 LSTMs中的“门”  </div> </center><p>首先是遗忘门，用来判断哪些信息应该删除。其中$\sigma$表示激活函数 sigmoid。输入的$h_{t-1}$和$x_t$经过 sigmoid 激活函数之后得到$f_t$，$f_t$中每一个值的范围都是 [0, 1]。$f_t$中的值越接近 1，表示对应位置的值更应该记住；越接近 0，表示对应位置的值更应该忘记。将 $f_t$与$C_{t-1}$按位相乘 (ElementWise 相乘)，即可以得到遗忘无用信息之后的$C_{t-1}^{‘}$。</p><center>      <img height="100%" width="100%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化8.png?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图8 遗忘门  </div> </center><p>其次是输入门，用来判断哪些新的信息应该记住。输入的$h_{t-1}$和$x_t$经过 tanh 激活函数可以得到新的输入信息$\tilde{C_{t}}$，但是这些新信息并不全是有用的，因此需要使用$h_{t-1}$和$x_t$经过sigmoid 函数得到$i_t$，$i_t$表示哪些新信息是有用的。两向量相乘后的结果加到$C_{t-1}^{‘}$中，即得到$C_t$。</p><center>      <img height="100%" width="100%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化9.png?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图9 输入门  </div> </center><p>现在，我们已经知道如何更新$C$了</p><center>      <img height="100%" width="100%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化10.png?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图10 更新cell state  </div> </center><p>最后是输出门，用来判断应该输出哪些信息到$h_t$中。$C_t$经过 tanh 函数(范围变为[-1, 1])得到应该输出的信息，然后$h_{t-1}$和$x_t$经过 sigmoid 函数得到一个向量$o_t$(范围[0, 1])，表示哪些位置的输出应该去掉，哪些应该保留。两向量相乘后的结果就是最终的$h_t$。</p><center>      <img height="100%" width="100%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化11.png?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图11 输出门  </div> </center><h1 id="Seq2Seq"><a href="#Seq2Seq" class="headerlink" title="Seq2Seq"></a>Seq2Seq</h1><p>Seq2Seq在2014年首次由Sutskever等人在<em>Sequence to Sequence Learning with Neural Networks</em><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="Sutskever I, Vinyals O, Le Q V. Sequence to Sequence Learning with Neural Networks[C]//Advances in neural information processing systems. 2014: 3104-3112.">[2]</span></a></sup>一文中提出，同年份Yoshua Bengio团队的<em>Learning Phrase Representation using RNN Encoder-Decoder for Statistical Machine Translatio</em>n<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Cho K, Van Merriënboer B, Gulcehre C, et al. Learning phrase representations using RNN encoder-decoder for statistical machine translation[J]. arXiv preprint arXiv:1406.1078, 2014.">[3]</span></a></sup>也独立的阐述了Seq2Seq的主要思想。</p><blockquote><p>两篇文章中提出的网络模型有些不同，这里主要围绕Sutskever等人提出的模型展开，借鉴于<em>Natural Language Processing with Deep Learning</em><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="Guillaume Genthial, Lucas Liu, Barak Oshri, Kushal Ranjan. CS224n: Natural Language Processing with Deep Learning , 2017.">[4]</span></a></sup>。</p></blockquote><p>Seq2Seq模型是一个端到端模型，可以看作由两个RNN网络(通常为LSTM)组成</p><ul><li>编码器，根据输入产生固定大小的中间语义向量$C$</li><li>解码器，根据中间语义向量$C$产生最终输出</li></ul><p>接下来分别介绍编码器与解码器是如何工作的</p><center>      <img height="30%" width="30%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化12.png?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图12 编码器  </div> </center><p>编码器需要接收输入序列，产生中间语义向量，但是将一个任意长度的输入序列转换为固定长度的$C$对于单层架构来说太困难了，通常我们会使用多层，图中展示的是三层LSTMs架构，最后一层LSTM层的输出将作为$C$。</p><p>此外，Seq2Seq通常会逆序输入原序列(注意图中Timesteps的箭头指向)，这样一来，编码器最后的输出将会是原序列的首个元素，解码器在解码过程中遇到的首个输入正好对应原序列的首元素。这对最终结果是有利的，如文本任务，当解码器正确翻译了前面一部分单词，将很容易猜出完整的句子。</p><center>      <img height="30%" width="30%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化13.png?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图13 解码器  </div> </center><p>解码器同样是一个LSTM多层网络，但结构更复杂一些，每一层的输出将作为下一层的输入。使用上文中得到的$C$初始化解码器，并输入一个开始信号(在文本任务中，通常为<code>&lt;EOS&gt;</code>)，最终得到输出序列，输入序列和输出序列长度不要求相同。</p><p>得到输出序列后，我们可以定义loss，使用梯度下降和后向传播最小化loss，训练我们的编码器和解码器。</p><p class="note note-primary">  <b>Bidirectional RNNs</b></p><p>对于某个句子，当前的单词也许和它之前、之后两个方向的单词均有联系，但是目前的Seq2Seq结构只考虑了一个方向。Bidirectional RNNs以一种巧妙的结构解决了该问题。</p><center>      <img height="30%" width="30%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化14.png?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图14 单层bi-LSTM编码器示例  </div> </center><p>Bidirectional RNNs以前向、后向两种方式输入序列，输出也是由前向RNN和后向RNN共同组成的。</p><p class="note note-primary">  <b>Attention机制</b></p><p>一个句子中不同的单词，给予的关注度是不同的，如“the ball is on the field”，你会更关注”ball,” “on,” 和”field,”。因此， Bahdanau等人提出了一种解决方案<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="Bahdanau D, Cho K, Bengio Y. Bahdanau et al., 2014. Neural Machine Translation by Jointly Learning to Align and Translate[J]. arXiv preprint arXiv:1409.0473, 2014.">[5]</span></a></sup>，其中设计的关键一点便是Attention机制。</p><center>      <img height="30%" width="30%" src="https://github.com/HerloConnell/BlogPicture/blob/Optimization-problem/基于深度学习的组合优化15.png?raw=true">      <br>      <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">    图15 由给定的输入序列x生成t时刻的输出y  </div> </center><p>首先是编码器，使用bi-LSTM结构，设编码器隐藏层输出为$(h_1,…,h_n)$。</p><p>其次是解码器，这里与之前的大有不同，设$s_i$为$i$时刻隐藏层输出(隐状态)，其计算方法如下：</p><script type="math/tex; mode=display">s_i = f(s_{i-1}, y_{i-1}, c_i)</script><p>值得注意的是，不同于之前只有一个语义向量$C$的Seq2Seq，这里每个$y_i$均对应一个$c_i$，其中$c_i$是编码器隐状态的加权和。</p><script type="math/tex; mode=display">c_i= \sum_{j=1}^{T_x}{\alpha_{i,j}h_j}</script><p>$T_x$代表编码器隐状态总数，即输入序列长度。</p><p>权重$\alpha_{i,j}$由$e_{i,j}$经过$softmax$运算计算而来</p><script type="math/tex; mode=display">\alpha _{i,j} = \frac{exp(e_{i,j})}{\sum_{k=1}^{T_x}exp(e_{i,k}) }</script><p>那么$e_{i,j}$又是如何计算的呢</p><script type="math/tex; mode=display">e_{i,j} = a(s_{i-1}, h_j)</script><p>其中$a$代表某种对齐模型（如单层全连接层），即对$j$位置的输入和$i$时刻的输出，二者的匹配程度做一个评估，得到评估分数$e_{i,j}$。</p><p>可以看出，Attention的作用就是将encoder的隐状态按照一定权重加和之后拼接到decoder的隐状态上，以此作为额外信息，起到“软对齐”的作用，并且提高了整个模型的预测准确度。简单举个例子，在机器翻译中一直存在对齐的问题，也就是说源语言的某个单词应该和目标语言的哪个单词对应，如“Who are you”对应“你是谁”，如果我们简单地按照顺序进行匹配的话会发现单词的语义并不对应，显然“who”不能被翻译为“你”。而Attention机制非常好地解决了这个问题。如前所述，Attention会给输入序列的每一个元素分配一个权重，如在预测“你”这个字的时候输入序列中的“you”这个词的权重最大，这样模型就知道“你”是和“you”对应的，从而实现了软对齐。</p><h1 id="Pointer-Network"><a href="#Pointer-Network" class="headerlink" title="Pointer Network"></a>Pointer Network</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>此外，感谢以下博客，做了很好的总结</p><p><a href="https://blog.csdn.net/jerr__y/article/details/53749693">永永夜. seq2seq学习笔记</a></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Christopher Olah.<a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Sutskever I, Vinyals O, Le Q V. <a href="https://arxiv.org/abs/1409.3215">Sequence to Sequence Learning with Neural Networks</a>[C]//Advances in neural information processing systems. 2014: 3104-3112.<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>Cho K, Van Merriënboer B, Gulcehre C, et al. <a href="https://arxiv.org/abs/1406.1078">Learning phrase representations using RNN encoder-decoder for statistical machine translation</a>[J]. arXiv preprint arXiv:1406.1078, 2014.<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>Guillaume Genthial, Lucas Liu, Barak Oshri, Kushal Ranjan. <a href="https://web.stanford.edu/class/archive/cs/cs224n/cs224n.1174/lecture_notes/cs224n-2017-notes6.pdf">CS224n: Natural Language Processing with Deep Learning </a>, 2017.<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>Bahdanau D, Cho K, Bengio Y. Bahdanau et al., 2014. <a href="https://arxiv.org/abs/1409.0473">Neural Machine Translation by Jointly Learning to Align and Translate</a>[J]. arXiv preprint arXiv:1409.0473, 2014.<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>英语语法</title>
    <link href="/2021/09/05/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/09/05/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="句子的组成"><a href="#句子的组成" class="headerlink" title="句子的组成"></a>句子的组成</h1><p><strong>句子 = 主干 + 修饰部分</strong></p><p>其中，主干就是英语中五大句型（简单句)。</p><p class="note note-primary">  <b>五大句型</b></p> <pre><code class=" mermaid">graph LR简单句 --&gt; 主谓主谓 --&gt; id1[&quot;we meet&quot;]简单句 --&gt; 主谓宾主谓宾 --&gt; id2[&quot;I like it&quot;]简单句 --&gt; 主谓宾宾主谓宾宾 --&gt; id3[&quot;I give you my heart&quot;]简单句 --&gt; 主谓宾补主谓宾补 --&gt; id4[&quot;You make me happy&quot;]简单句 --&gt; 主系表主系表 --&gt; id5[&quot;You are my destiny&quot;]</code></pre><ol><li><p>主谓(一个句子最不可或缺的两个部分）：You jump；I jump.</p></li><li><p>主谓宾（宾语是主语动作的对象)：I love him.</p></li><li><p>主谓宾（人）宾（物）：please do me(人） a favor（物）.（检验是双宾语的原则：两个宾语可以调换位置，增加相应介词 to/for please do a favor for me ）</p></li><li><p>主谓宾补（补充说明宾语）：I found the book easy(the book 是found 的对象，easy是用来修饰the book 的)（检验是宾补的原则：宾语和补语之间加一个系动词，可以构成语义通顺的句子 the book is easy）</p></li><li><p>主系表（说明主语的状态特点）：She is pretty.</p></li></ol><p class="note note-primary">  <b>句子中的修饰成分</b></p> <p>五种基本句型，是解读英语句子和构造英语句子的基础，任何高阶复杂的句子都是从这五种简单句型通过扩大，组合，省略或倒装等变化而来。</p><p>修饰成分包括<strong>定语</strong>和<strong>状语</strong>，定语负责修饰限定名词，状语负责把句子壮大。</p><pre><code class=" mermaid">graph LR定语-修饰限定名词 --&gt;  形容词定语-修饰限定名词 --&gt;  定语从句 --&gt; 引导词+陈述句定语-修饰限定名词 --&gt;  介词短语 --&gt; 介词+名词定语-修饰限定名词 --&gt;  非谓语动词 非谓语动词 --&gt; id1[&quot;to do&quot;]非谓语动词 --&gt; id2[&quot;doing&quot;]非谓语动词 --&gt; id3[done]</code></pre><ol><li><p><strong>形容词：</strong>She is a <strong>lovely</strong> girl. 她是一位可爱的女孩。</p></li><li><p><strong>定语从句：</strong>New York is the place <strong>that he would like to visit</strong>. 纽约是他想去游览的地方。</p></li><li><p><strong>介词短语</strong>：The girl <strong>in red</strong> is my sister. 穿红色那个女孩是我的妹妹。</p></li><li><p><strong>非谓语动词</strong>：the girl <strong>standing</strong> there is my sister.</p><p>​                       the girl <strong>who is standing</strong> there is my sister. 站在那的女孩是我的妹妹。</p><p>​                       the building <strong>completed</strong> yesterday…=the building <strong>that was completed</strong> yesterday… 昨天竣工的楼房…</p><p>​                       I have something <strong>to say</strong>.</p></li></ol><p>从上面非谓语例句可以看到<strong>非谓语动词可以变成定语从句</strong></p><pre><code class=" mermaid">graph LR状语-扩大句子 --&gt; 名词状语-扩大句子 --&gt; 副词状语-扩大句子 --&gt; 状语从句 --&gt; 引导词+陈述句状语-扩大句子 --&gt;  介词短语 --&gt; 介词+名词状语-扩大句子 --&gt; 非谓语动词非谓语动词 --&gt; id1[&quot;to do&quot;]非谓语动词 --&gt; id2[&quot;doing&quot;]非谓语动词 --&gt; id3[done]</code></pre><ol><li><p><strong>名词</strong>:  come <strong>this way.</strong> </p></li><li><p><strong>副词</strong>: speak <strong>politely.</strong></p></li><li><p><strong>介词短语</strong>：Can you say it <strong>in English.</strong></p></li><li><p><strong>状语从句</strong>：I enjoyed myself <strong>when I visited my friends in Shanghai last year.</strong></p></li><li><p><strong>非谓语动词：Having finished the homework,</strong> I went home.</p><p>​                       <strong>Given more time</strong>, I could write the essay better.</p><p>​                       <strong>To give the teacher a good impression</strong>, I decided  to help her.</p></li></ol><h1 id="Present-and-past"><a href="#Present-and-past" class="headerlink" title="Present and past"></a>Present and past</h1><h2 id="Unit-1-Present-continuous-I-am-doing"><a href="#Unit-1-Present-continuous-I-am-doing" class="headerlink" title="Unit 1: Present continuous (I am doing)"></a>Unit 1: Present continuous (I am doing)</h2><p><strong>I am</strong>=<strong>doing</strong> something =  I’m in the middle of doing it; I’ve started doing it and I haven’t finished.</p><ul><li><p>I am eating food.</p></li><li><p>I am taking a corporate training course.</p></li></ul><hr><p>Sometimes the action is not happening at the time of speaking. For example: </p><ul><li><p>Steve is talking to a friend on the phone. He says:</p></li><li><p>I’m <strong>reading</strong> a really good book at the moment. it’s about a man who …</p></li></ul><p>Steve is not reading the book at the time of speaking.He means that he has started it, but has not finished it yet. He is in the middle of reading it.</p><hr><p>You can use the present continuous with <strong>today</strong> <strong>/</strong> <strong>this week</strong> <strong>/</strong> <strong>this year</strong> etc. (periods around now)</p><ul><li><p>You’re <strong>working hard today. </strong>(<em>not</em> You work hard today)</p></li><li><p>The company I work for <strong>isn’t doing</strong> so well <strong>this year.</strong></p></li></ul><hr><p>We use the present continuous when we talk about changes happening around now, especially with these verbs:</p><p><strong><code>get</code>, <code>change</code>, <code>become</code>, <code>increase</code>, <code>rise</code>, <code>fall</code>, <code>grow</code>, <code>improve</code>, <code>begin</code>, <code>start</code></strong></p><ul><li><p><strong>Is</strong> your English <strong>getting</strong> better?( <em>not</em> Does your English get better)</p></li><li><p>The world <strong>is changing</strong>.</p></li><li><p>The population of the world <strong>is</strong> <strong>increasing</strong> very fast. (<em>not</em> increases)</p></li><li><p>At first I didn’t like my job, but I’m <strong>beginning</strong> to enj oy it now. <em>(not</em> I begin)</p></li></ul><hr><h2 id="Unit-2-Present-simple-I-do"><a href="#Unit-2-Present-simple-I-do" class="headerlink" title="Unit 2: Present simple (I do)"></a>Unit 2: Present simple (I do)</h2><p>We use the present simple to talk about things in general. We use it to say that something happens all the time or repeatedly/ or that something is true in general.</p><ul><li><p>Nurses <strong>look</strong> after patients in hospitals. </p></li><li><p>I usually <strong>go</strong> away at weekends.</p></li><li><p>The cafe <strong>opens</strong> at 7.30 in the morning.</p></li></ul><hr><p>We use <strong>do/does</strong> to make questions and negative sentences (<strong>auxiliary verb</strong>).</p><ul><li><p><strong>do</strong> I/we/you/they <strong>work?</strong> </p></li><li><p>he/she/it <strong>doesn’t</strong> <strong>do</strong></p></li><li><p>I come from Canada. Where <strong>do</strong> you <strong>come</strong> from?</p></li><li><p>I <strong>don’t go</strong> away very often.</p></li><li><p>What <strong>does</strong> this word <strong>mean?</strong> (<em>not</em> What means this word?) </p></li></ul><p>In the following examples, <strong>do</strong> is also the <strong>main verb</strong> (do you <strong>do</strong>/doesn’t <strong>do</strong> etc.): </p><ul><li>‘What <strong>do</strong> you <strong>do</strong>?’   ‘I work in a shop.’</li></ul><hr><p>We use the present simple to say how often we do things:</p><ul><li><p>I <strong>get</strong> up at 8 o’clock <strong>every morning.</strong></p></li><li><p><strong>How often</strong> do you <strong>go</strong> to the dentist?</p></li><li><p>Julie <strong>doesn’t drink</strong> tea <strong>very often.</strong></p></li><li><p>Robert usually <strong>goes</strong> away <strong>two or three times a year.</strong></p></li></ul><hr><p><strong>I promise</strong>/<strong>I apologise</strong> etc.</p><p>Sometimes we do things by saying something. For example, when you <em>promise</em> to do something, you can say ‘I <strong>promise …</strong>‘; when you <em>suggest</em> something, you can say ‘I <strong>suggest …</strong>‘, In the same way we say: <strong>I apologise</strong> .. . / <strong>I advise</strong> … / <strong>I insist</strong> … / <strong>I agree</strong> … / <strong>I refuse</strong> … etc.</p><ul><li><p>I <strong>promise</strong> I won’t be late. <em>(not</em> I’m promising)</p></li><li><p>‘What do you <strong>suggest</strong> I do?’ ‘I <strong>suggest</strong> that you … ‘</p></li></ul><h2 id="Unit-3-Present-continuous-and-present-simple-1-I-am-doing-and-I-do"><a href="#Unit-3-Present-continuous-and-present-simple-1-I-am-doing-and-I-do" class="headerlink" title="Unit 3: Present continuous and present simple 1 (I am doing and I do)"></a>Unit 3: Present continuous and present simple 1 (I am doing and I do)</h2><p>Compare:</p><div class="table-container"><table><thead><tr><th>Present continuous(I am doing)</th><th>Present Simple(I do)</th></tr></thead><tbody><tr><td>now</td><td>paste ⬅️ now ➡️ future</td></tr><tr><td><strong>We use the continuous for things happening at or around the time of speaking. The action is not complete</strong>.  <em>Example</em>: The water <strong>is boiling</strong>, Can you turn it off ?</td><td><strong>We use the simple for things in general or things that happen repeatedly.</strong>  <em>Example</em>: Water <strong>boils</strong> at 100 degrees Celsius.</td></tr><tr><td><strong>We use the continuous for <em>temporary</em> situations</strong>. <em>Example</em>: I<strong>‘m living</strong> with some friends until I find a place of my own.</td><td><strong>We use the simple for <em>permanent</em> situations</strong>. <em>Example</em>: My parents <strong>live</strong> in London. They have lived there all their lives.</td></tr></tbody></table></div><hr><p><strong>I always do</strong> and <strong>I’m always doing</strong></p><p>I always do (something) = I do it every time:</p><ul><li>I always go to work by car. (<em>not</em> I’m always going)</li></ul><p>‘I<strong>‘m always doing</strong> something’ has a different meaning. </p><p>I<strong>‘m always losing</strong> things = I lose things very often, perhaps too often, or more often than normal.</p><ul><li><p>I’ve lose my phone again. I’m always losing things.</p></li><li><p>You’re always playing computer games. You should do something more active.(=You play computer games too often)</p></li><li><p>Tim is never satisfied. He’s always complaining. (=He complains too much)</p></li></ul><h2 id="Unit-4-Present-continuous-and-present-simple-2-I-am-doing-and-I-do"><a href="#Unit-4-Present-continuous-and-present-simple-2-I-am-doing-and-I-do" class="headerlink" title="Unit 4: Present continuous and present simple 2 (I am doing and I do)"></a>Unit 4: Present continuous and present simple 2 (I am doing and I do)</h2><p>We use continuous forms for actions and happenings that have started but not finished. Some verbs (for example, <strong>know</strong> and <strong>Like)</strong> are not normally used in this way. We don’t say ‘I am knowing’ or ‘they are liking’; we say ‘I <strong>know</strong>‘, ‘they <strong>Like’.</strong></p><p>The following verbs are not normally used in the present continuous:</p><p><code>like</code>, <code>want</code>, <code>need</code>, <code>prefer</code>, <code>know</code>, <code>realise</code>, <code>belong</code>, <code>fit</code>, <code>suppose</code>, <code>mean</code>, <code>understand</code>, <code>believe</code>, <code>remember</code>, <code>contain</code>, <code>consist</code>, <code>seem</code>, …</p><ul><li>I’m hungry. I <strong>want</strong> something to eat. (<em>not</em> I’m wanting)</li><li>Do you <strong>understand</strong> what I mean?</li><li>Anna <strong>doesn’t seem</strong> very happy at the moment.</li></ul><hr><p><strong>Think</strong></p><p>When <strong>think</strong> means ‘believe’ or ‘have an opinion’, we do not use the continuous: </p><ul><li>I <strong>think</strong> Mary is Canadian, but I’m not sure. <em>(not</em> I’m thinking)</li><li>What <strong>do</strong> you <strong>think</strong> of my plan? (=What is your opinion?)</li></ul><p>When <strong>think</strong> means ‘consider’, the continuous is possible:</p><ul><li>I’m <strong>thinking</strong> about what happened. I often <strong>think</strong> about it.</li><li>Nicky <strong>is thinking</strong> of giving up her job. (=she is considering it)</li></ul><hr><p><strong>See hear smell taste</strong></p><p>We normally use the present simple (not continuous) with these verbs: </p><ul><li><p><strong>Do</strong> you <strong>see</strong> that man over there? <em>(not</em> Are you seeing)</p></li><li><p>This room <strong>smells.</strong> Lefs open a window.</p></li></ul><p>We often use <strong>can + see/ hear/smell/taste</strong>:</p><ul><li><strong>I can hear</strong> a strange noise. <strong>Can</strong> you <strong>hear</strong> it?</li></ul><hr><p><strong>Look feel</strong></p><p>You can use the present simple or continuous to say how somebody looks or feels now: </p><ul><li><p>You <strong>Look</strong> well today. or You’re <strong>Looking</strong> well today.</p></li><li><p>How <strong>do</strong> you <strong>feel</strong> now? or How <strong>are</strong> you <strong>feeling</strong> now? </p></li></ul><hr><p><strong>He is selfish</strong> and <strong>He</strong> <strong>is being selfish</strong></p><p>He’s <strong>being =</strong> He’s behaving/He’s acting. Compare:</p><ul><li><p>I can’t understand why he’s <strong>being</strong> so selfish. He isn’t usually like that.</p><p><strong>(being</strong> selfish = behaving selfishly at the moment)</p></li><li><p>He never thinks about other people. He <strong>is</strong> very selfish. <em>(not</em> He is being)</p><p>(= He is selfish generally, not only at the moment)</p></li></ul><p>We use <strong>am/is/are being</strong> to say how somebody is <em>behaving.</em> lt is not usually possible in other sentences :</p><ul><li>it’s hot today. <em>(not</em> lt is being hot)</li><li>Sarah <strong>is</strong> very tired . <em>(not</em> is being tired)</li></ul><h2 id="Unit-5-Past-simple-I-did"><a href="#Unit-5-Past-simple-I-did" class="headerlink" title="Unit 5: Past simple (I did)"></a>Unit 5: Past simple (I did)</h2><p>In questions and negatives we use <strong>did/didn’t+</strong> <em>infinitive</em> <strong>(enjoy/see/go</strong> etc.):</p><ul><li><p>A: <strong>Did</strong> you <strong>go</strong> out last night?</p><p>B: Yes, I <strong>went</strong> to the cinema, but I <strong>didn’t enjoy</strong> the film much.</p></li></ul><p>In the following examples, <strong>do</strong> is the main verb in the sentence <strong>(did</strong> … <strong>do</strong> <strong>/</strong> <strong>didn’t do):</strong> </p><ul><li>What <strong>did</strong> you <strong>do</strong> at the weekend? <em>(not</em> What did you at the weekend?)</li><li>I <strong>didn’t do</strong> anything. <em>(not</em> I didn’t anything)</li></ul><h2 id="Unit-6-Past-continuous-I-was-doing"><a href="#Unit-6-Past-continuous-I-was-doing" class="headerlink" title="Unit 6: Past continuous (I was doing)"></a>Unit 6: Past continuous (I was doing)</h2><ul><li>Yesterday Karen and jim played tennis. They started at 10 o’clock and finished at 11.30.So, at 10.30 they <strong>were playing</strong> tennis.</li></ul><p>They <strong>were playing</strong> = they were in the middle of playing. They had not finished playing.</p><p><strong>Was/were -ing</strong> is the <em>past continuous:</em></p><p><strong>I was doing</strong> something= I was in the middle of doing something at a certain time. The action or situation had already started before this time, but had not finished:</p><ul><li>This time last year I was living in Brazil.</li><li>What were you doing at 10 o’clock last night?</li></ul><hr><p>We often use the past simple and the past continuous together to say that something happened in the middle of something else:</p><ul><li>Matt <strong>phoned</strong> while we <strong>were having</strong> dinner.</li><li>lt was <strong>raining</strong> when I <strong>got</strong> up.</li><li>I <strong>saw</strong> you in the park yesterday. You <strong>were sitting</strong> on the grass and <strong>reading</strong> a book. </li></ul><p>But we use the past simple to say that one thing happened after another:</p><ul><li>I <strong>was walking</strong> along the road when I <strong>saw</strong> Dan. So I <strong>stopped</strong>, and we <strong>had</strong> a chat.</li><li>When Karen arrived, we were having dinner. (= we had already started before she arrived)</li><li>When Karen arrived, we had dinner. (= Karen arrived, and then we had dinner)</li></ul><hr><h1 id="Present-perfect-and-past"><a href="#Present-perfect-and-past" class="headerlink" title="Present perfect and past"></a>Present perfect and past</h1><h2 id="Unit-7-Present-perfect1-I-have-done"><a href="#Unit-7-Present-perfect1-I-have-done" class="headerlink" title="Unit 7: Present perfect1 (I have done)"></a>Unit 7: Present perfect1 (I have done)</h2><ul><li>Tom is looking for his key. He can’t find it. He <strong>has lost</strong> his key.</li></ul><p>He <strong>has lost</strong> his key = He lost it recently, and he still doesn’t have it.</p><p>The present perfect simple is <strong>have/has</strong>+ <em>past participle.</em> </p><hr><p>When we say that ‘something has happened’, this is usually new information:</p><ul><li>Ow! I<strong>‘ve cut</strong> my finger.</li><li>The road is closed. There<strong>‘s been</strong> (there <strong>has been</strong>) an accident.</li><li>Police <strong>have arrested</strong> two men in connection with the robbery.</li></ul><p>When we use the present perfect, <strong>there is a connection with <em>now.</em> The action in the past has a result now</strong>:</p><ul><li>‘Where’s your key?’ ‘I don’t know. I’ve lost it.’ (=I don’t have it <em>now</em>)</li><li>‘Is Sally here?’ ‘No, she’s gone out.’ (=she is out <em>now)</em></li><li>I can’t find my bag. Have you seen it? (= Do you know where it is <em>now?)</em></li></ul><hr><p>Note the <strong>difference between gone (to) and been (to)</strong>:</p><ul><li>James is on holiday. He <strong>has gone</strong> to Italy. (= he is there now or on his way there)</li><li>Jane is back home now. She <strong>has been</strong> to Italy. (=she has now come back)</li></ul><hr><p>You can use the present perfect with <strong>just</strong>, <strong>already</strong> and <strong>yet</strong>.</p><p><strong>just</strong> = a short time ago:</p><ul><li>‘Are you hungry?’ ‘No, I<strong>‘ve just had</strong> lunch.’</li><li>Hello. Have you <strong>just arrived</strong>?</li></ul><p><strong>already</strong> = something happened sooner than expected:</p><ul><li>‘Don’t forget to pay your electricity bill.’ ‘I’<strong>ve already paid</strong> it.’</li><li>‘What time is Mark leaving?’ ‘He<strong>‘s already left</strong>.’</li></ul><p><strong>yet</strong> = until now. <strong>yet</strong> shows that the speaker is expecting something to happen. Use yet  <strong>only in questions and negative</strong> sentences:</p><ul><li><p><strong>Has</strong> it <strong>stopped</strong> raining <strong>yet</strong>?</p></li><li><p>I <strong>‘ve written</strong> the email, but I <strong>haven’t sent</strong> it <strong>yet</strong>.</p></li></ul><hr><p>You can also use the past simple (<strong>did, went, had</strong> etc.) in the examples on this page. So you can say:</p><ul><li><p>‘Is Sally here?’ ‘No, she went out.’ <em>or</em> ‘No, she’s gone out.’</p></li><li><p>‘Are you hungry?’ ‘No, I just had lunch.’ <em>or</em>  ‘No, I’ve just had lunch.’</p></li></ul><h2 id="Unit-8-Present-perfect2-I-have-done"><a href="#Unit-8-Present-perfect2-I-have-done" class="headerlink" title="Unit 8: Present perfect2 (I have done)"></a>Unit 8: Present perfect2 (I have done)</h2><ul><li><p>DAVE: <strong>Have</strong> you <strong>travelled</strong> a lot, Jane? Yes, I’ve <strong>been</strong> to lots of places.</p></li><li><p>JANE: Really? <strong>Have</strong> you ever <strong>been</strong> to China? Yes, I’ve <strong>been</strong> to China twice.</p></li><li>DAVE: What about India?</li><li>JANE:  No, I <strong>haven’t been</strong> to India.</li></ul><p>When we talk about a period of time that continues from the past until now, we use the <em>present perfect</em> <strong>(have been</strong> <strong>I</strong> <strong>have traveLLed</strong> etc.). Here, Dave and jane are talking about the places Jane has visited in her life, which is a period that continues until now.</p><hr><ul><li><p><strong>Have</strong> you ever <strong>eaten</strong> caviar?</p></li><li><p>We<strong>‘ve</strong> never <strong>had</strong> a car.</p></li><li>Susan really loves that film. She’s <strong>seen</strong> it eight times!</li></ul><p><strong>Been</strong> <strong>(to)=</strong> visited:</p><ul><li>I’ve never <strong>been</strong> <strong>to</strong> China. Have you <strong>been</strong> there?</li></ul><hr><p>In the following examples too, the speakers are talking about a period that continues until now <strong>(recently</strong> <strong>/</strong> <strong>in</strong> <strong>the</strong> <strong>last few days</strong> <strong>/</strong> <strong>so far</strong> <strong>/</strong> <strong>since breakfast</strong> etc.):</p><ul><li><strong>Have</strong> you <strong>heard</strong> anything from Brian <strong>recently?</strong></li><li>I’ve <strong>met</strong> a lot of people <strong>in</strong> <strong>the</strong> <strong>last</strong> <strong>few</strong> <strong>days.</strong></li><li><p>Everything is going well. We <strong>haven’t had</strong> any problems <strong>so far</strong>.</p></li><li><p>I’m hungry. I <strong>haven’t eaten</strong> anything <strong>since breakfast.</strong> (=from breakfast until now)</p></li><li>lt’s good to see you again. We <strong>haven’t seen</strong> each other <strong>for a Long time.</strong></li></ul><hr><p>In the same way we use the present perfect with <strong>today</strong> <strong>/</strong> <strong>this evening</strong> <strong>/</strong> <strong>this year</strong> etc. when these periods are not finished at the time of speaking:</p><ul><li>I’ve <strong>drunk</strong> four cups of coffee today.</li><li><strong>Have</strong> you <strong>had</strong> a holiday <strong>this year?</strong></li><li>I <strong>haven’t seen</strong> Tom <strong>this morning. Have</strong> you? </li><li>Rob <strong>hasn’t worked</strong> very hard <strong>this</strong> <strong>term</strong>.</li></ul><hr><p>We say: lt’s the (first) time something <strong>has happened.</strong> For example:</p><ul><li><p>Don is having a driving lesson. lt’s his first one. </p><p>lt’s the first time he <strong>has driven</strong> a car. <em>(not</em> drives)</p></li><li><p>He <strong>has never driven</strong> a car <strong>before.</strong></p></li><li><p>Bill is phoning his girlfriend again. That’s the third time he’s <strong>phoned</strong> her <strong>this evening.</strong> <em>(not</em> happens)</p></li></ul><h2 id="Unit-9-Present-perfect-continuous-I-have-been-doing"><a href="#Unit-9-Present-perfect-continuous-I-have-been-doing" class="headerlink" title="Unit 9: Present perfect continuous(I have been doing)"></a>Unit 9: Present perfect continuous(I have been doing)</h2><ul><li><strong>lt has been raining</strong></li></ul><p>Study this example situation:</p><ul><li>‘Is it raining?’ ‘No, but the ground is wet.’</li><li>lt <strong>has been raining</strong>.</li></ul><p><strong>Have/has been -ing</strong> is the <em>presentperfect continuous:</em></p><p>We use the present perfect continuous for an activity that has recently stopped or just stopped. There is a connection with <em>now:</em></p><ul><li>You’re out of breath. Have you been running? (= you’re out of breath <em>now)</em></li><li>Paul is very tired. He’s been working very hard. (= he’stired <em>now)</em> </li><li>Why are your clothes so dirty? What have you been doing?</li><li>I’ve been talking to Amanda about the problem and she agrees with me.</li><li>Where have you been? I’ve been looking for you everywhere.</li></ul><hr><ul><li><strong>lt has been raining for two hours</strong>.</li></ul><p>lt began raining two hours ago and it is still raining.</p><ul><li>‘How long <strong>has</strong> it  <strong>been raining</strong> ?’  ‘lt <strong>has been raining</strong> for two hours.’</li></ul><p>We use the present perfect continuous in this way especially with <strong>how long</strong>, <strong>for</strong> … and <strong>since</strong> …. The activity is still happening (as in this example) or has just stopped.</p><ul><li>How long <strong>have you been Learning</strong> English? (=you’re still learning English)</li><li>Tim is still watching TV. He<strong>‘s been watching</strong> TV all day.</li><li>Where have you been? I<strong>‘ve been looking</strong> for you <strong>for the last half hour</strong>.</li><li><p>Chris <strong>hasn’t been feeling</strong> well recently.</p><p>You can use the present perfect continuousfor actions repeated over a period of time:</p></li><li><p>Silvia is a very good tennis player. She’s been playing since she was eight.</p></li><li>Every morning they meet in t he same cafe. They’ve been going there for years.</li></ul><h2 id="Unit10-Present-perfect-continuous-and-Present-perfect-I-have-been-doing-and-I-have-done"><a href="#Unit10-Present-perfect-continuous-and-Present-perfect-I-have-been-doing-and-I-have-done" class="headerlink" title="Unit10: Present perfect continuous and Present perfect (I have been doing and I have done)"></a>Unit10: Present perfect continuous and Present perfect (I have been doing and I have done)</h2><blockquote><p>I am confused for this section, the difference between the present perfect continuous and the present perfect seems not so much…..but I still record that.</p></blockquote><ul><li><strong>I’ve been painting</strong> my bedroom.</li></ul><p>We are <strong>thinking of the activity</strong>. <strong>lt does not matter whether it has been finished or not</strong>. In this example, the activity (painting the bedroom) has not been finished.</p><ul><li>I<strong>‘ve painted</strong> my bedroom.</li></ul><p>Here, the important thing is that something has been finished. We are interested in <strong>the result of the activity</strong> (the painted bedroom), not the activity itself.</p><hr><p>Present perfect continuous</p><ul><li>My hands are very dirty. I’ve been repairing my bike.</li><li>Joe has been eating too much recently. He should eat less.</li><li>lt’s nice to see you again. What have you been doing since we last met?</li><li>Where have you been? Have you been playing tennis?</li></ul><p>Present perfect</p><ul><li>My bike is OK again now. I’ve repaired it.</li><li>Somebody has eaten all the chocolates. The box is empty.</li><li>Where’s the book I gave you? What have you done with it?</li><li>Have you ever played tennis?</li></ul><hr><p>We use the continuous to say <em>how</em> <em>long</em> (for something that is still happening):</p><ul><li>How long have you been reading that book?</li><li>Lisa is writing emails. She’s been writing emails all morning.</li><li>They’ve been playing tennis since 2 o’clock.</li></ul><p>We use the simple to say <em>how</em> <em>much, how</em> <em>many</em> or <em>how many times:</em></p><ul><li>How much of that book have you read ?</li><li>Lisa is writing emails. She’s sent lots of emails this morning.</li><li>They’ve played tennis three times this week.</li><li>I’m learning Arabic, but I haven’t learnt very much yet.</li></ul><hr><p>Some verbs (for example, know/like/believe) are not normally used in the continuous:</p><ul><li>I’ve known about the problem for a long time. <em>(not</em> I’ve been knowing)</li><li>How long have you had that camera? <em>(not</em> have you been having)</li></ul><p>But note that you <em>can</em> use <strong>want</strong> and <strong>mean</strong> in the present perfect continuous:</p><ul><li>I’ve been meaning to phone Jane1 but I keep forgetting.</li></ul><h2 id="Unit11-How-long-have-you-been-…"><a href="#Unit11-How-long-have-you-been-…" class="headerlink" title="Unit11:  How long have you (been) … ?"></a>Unit11:  How long have you (been) … ?</h2><p>Dan and Jenny are married. They got married exactly 20 years ago, so today is their 20th wedding anniversary.</p><p>They <strong>have been married</strong> for 20 years. </p><p>We say: They are married. <em>(present)</em></p><p><em>but</em> <strong>How long have they been married</strong>? <em>(present perfect)  (not</em> How long are they married?)</p><p>They have been married for 20 years. <em>(not</em> They are married for 20 years)</p><hr><p>We use the <em>present perfect</em> to talk about something that began in the past and still continues now.</p><p>Compare the <em>present</em> and the <em>present perfect:</em></p><ul><li><p>Paul is in hospital.</p><p>He<strong>‘s been</strong> in hospital since Monday. <em>(not</em> Paul is in hospital since Monday)</p></li></ul><hr><p>I <strong>have known / had / lived</strong> etc. is the <em>present perfect simple.</em></p><p>I <strong>have been learning/been waiting/been doing</strong> etc. is the <em>present perfect continuous</em></p><p>When we ask or say ‘how long’, the continuous is more usual:</p><ul><li>I’ve been learning English for six months.</li><li>lt’s been raining since Lunchtime.</li><li>Richard has been doing the same job for 20 years. </li><li>‘How long have you been driving?’ ‘Since I was 17.’</li></ul><p>Some verbs (for example, <strong>know/like/believe/have</strong>) are not normally used in the continuous:</p><ul><li>How long have you <strong>known</strong> jane? <em>(not</em> have you been knowing)</li><li>I<strong>‘ve had</strong> a pain in my stomach all day. <em>(not</em> I’ve been having)</li></ul><hr><p>You can use either the present perfect continuous or simple with live and work:</p><ul><li>Julia has been living I has lived here for a long time.</li><li>How long have you been working I have you worked here?</li></ul><p>But use the simple (I<strong>‘ve lived</strong> I I<strong>‘ve done</strong> etc.) with <strong>always</strong>:</p><ul><li>I’ve always lived in the country. <em>(not</em> always been living)</li></ul><hr><p>We say ‘<strong>I haven’t done something since/for</strong> …’ (present perfectsimple):</p><ul><li>I haven’t seen Tom since Monday. (= Monday was the last time I saw him) </li><li>Sarah hasn’t phoned for ages. (=the last time she phoned was ages ago)</li></ul><h2 id="Unit12-For-and-since-When-…-and-How-Long-…"><a href="#Unit12-For-and-since-When-…-and-How-Long-…" class="headerlink" title="Unit12:  For and since        When … ? and How Long … ?"></a>Unit12:  For and since        When … ? and How Long … ?</h2><p>We use <strong>for</strong> and <strong>since</strong> to say how long something has been happening.</p><p>We use <strong>for</strong> + a period of time (two hours, six weeks etc.):</p><ul><li>I’ve been waiting for two hours.</li><li>Sally has been working here for six months. <em>(not</em> since six months)</li><li>I haven’t seen Tom for three days.</li></ul><p>We use <strong>since</strong> + the start of a period (8 o’clock, Monday,1999 etc.):</p><ul><li>Sally has been working here since April. (=from April until now)</li><li>I haven’t seen Tom since Monday.</li></ul><p>lt is possible to leave out <strong>for</strong> (but not usually in negative sentences):</p><ul><li>They’ve been married (for) ten years. (with or without for) </li><li>They haven’t had a holiday for ten years. (you must use for)</li></ul><p>We do <em>not</em> use <strong>for+ all</strong> … (all day <em>I</em> all my life etc.): </p><ul><li>I’ve lived here all my life. <em>(not</em> for all my life)</li></ul><p>You can use <strong>in</strong> instead of <strong>for</strong> in <strong>negative</strong> sentences (I haven’t … etc.): </p><ul><li>They haven’t had a holiday in ten years. (=for ten years)</li></ul><hr><p>Compare <strong>when</strong> … ? <em>(+past simple)</em> and <strong>how long</strong> … ? <em>(+present perfect):</em></p><ul><li><p>A: <strong>When</strong> did Joe and Carol first meet?<br>B: They first met <strong>when they were at school</strong>. (or <strong>a long time ago</strong>.)</p></li><li><p>A: How long have they known each other?<br>B: They’ve known each other <strong>for a long time</strong>. (or <strong>since they were at school</strong>.)</p></li></ul><hr><p><strong>lt’s</strong> or <strong>lt’s been</strong> + a long time + since something happened.</p><ul><li><p><strong>lt’s two years since</strong> I last saw Joe. or <strong>lt’s been two years since</strong>… (= I haven’t seen Joe for two years)</p></li><li><p><strong>How Long is it since</strong> Mrs Hill died? or <strong>How long has it been since</strong> .. . ? (= When did Mrs Hill die?)</p></li></ul><h2 id="Unit13-Present-perfect-and-past-1-I-have-done-and-I-did"><a href="#Unit13-Present-perfect-and-past-1-I-have-done-and-I-did" class="headerlink" title="Unit13: Present perfect and past 1 (I have done and I did)"></a>Unit13: Present perfect and past 1 (I have done and I did)</h2><p>The present perfect (something has happened) is a <em>present</em> tense. lt <strong>always tells us about the situation now</strong>. ‘Tom has lost his key’= he doesn’t have his key <em>now</em>.</p><p>The past simple (something happened) <strong>tells us only about the past</strong>. If somebody says ‘Tom lost his key’, this doesn’t tell us whether he has the key now or not. lt tells us only that he lost his key at some time in the past.</p><p>Do <em>not</em> use the present perfect if the situation now is different. </p><ul><li>They went away, but I think they’re back at home now. <em>(not</em> They’ve gone)</li></ul><hr><p>You can use the present perfect for <strong>new or recent</strong> happenings:</p><ul><li>‘I’ve repaired the washing machine. lt’s working OK now.’ ‘Oh, that’s good.’</li></ul><p>Usually, you <strong>can also use</strong> the past simple:</p><ul><li>I repaired the washing machine. lt’s working OK now.</li></ul><p>Use the past simple <em>(not</em> the present perfect) for things that are <strong>not recent or new</strong>:</p><ul><li>My mother grew up in Italy. <em>(not</em> has grown)</li></ul><p>Compare:</p><ul><li>Did you know that somebody has invented a new type of washing machine?</li><li>Who invented the telephone? <em>(not</em> has invented)</li></ul><hr><p>We use the present perfect to give new information. But if we <strong>continue to talk about it</strong>, we normally use the past simple:</p><ul><li><p>A : Ow! I’ve burnt myself.</p><p>B: How did you do that? <em>(not</em> have you done) </p><p>A: I picked up a hot dish. <em>(not</em> have picked)</p></li><li><p>A: Look! Somebody has spilt something on the sofa.</p><p>B: Well, it wasn’t me. I didn’t do it. <em>(not</em> hasn’t been … haven’t done)</p></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]English Grammar in Use Answers 4th</p><p><a href="http://www.yinwang.org/blog-cn/2018/11/23/grammar">[2]王垠.解谜英语语法</a></p>]]></content>
    
    
    <categories>
      
      <category>英语基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql基础语法</title>
    <link href="/2021/08/26/Mysql%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/08/26/Mysql%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>brew安装Mysql</strong></p><div class="code-wrapper"><pre><code class="hljs no">lihan@LideMacBook-Air ~ % brew install mysql==&gt; Installing mysql==&gt; Summary🍺  /opt/homebrew/Cellar/mysql/8.0.26: 303 files, 296.7MB==&gt; mysqlWe&#x27;ve installed your MySQL database without a root password. To secure it run:    mysql_secure_installationMySQL is configured to only allow connections from localhost by defaultTo connect run:    mysql -urootTo have launchd start mysql now and restart at login:  brew services start mysqlOr, if you don&#x27;t want/need a background service you can just run:  mysql.server startlihan@LideMacBook-Air ~ % mysql.server startStarting MySQL.. SUCCESS! lihan@LideMacBook-Air ~ % mysql_secure_installationSecuring the MySQL server deployment.Connecting to MySQL using a blank password.VALIDATE PASSWORD COMPONENT can be used to test passwordsand improve security. It checks the strength of passwordand allows the users to set only those passwords which aresecure enough. Would you like to setup VALIDATE PASSWORD component?Press y|Y for Yes, any other key for No: yThere are three levels of password validation policy:LOW    Length &gt;= 8MEDIUM Length &gt;= 8, numeric, mixed case, and special charactersSTRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary                  filePlease enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 2Please set the password for root here.New password: Re-enter new password: Estimated strength of the password: 100 Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : yBy default, a MySQL installation has an anonymous user,allowing anyone to log into MySQL without having to havea user account created for them. This is intended only fortesting, and to make the installation go a bit smoother.You should remove them before moving into a productionenvironment.Remove anonymous users? (Press y|Y for Yes, any other key for No) : ySuccess.Normally, root should only be allowed to connect from&#x27;localhost&#x27;. This ensures that someone cannot guess atthe root password from the network.Disallow root login remotely? (Press y|Y for Yes, any other key for No)  n     ... skipping.By default, MySQL comes with a database named &#x27;test&#x27; thatanyone can access. This is also intended only for testing,and should be removed before moving into a productionenvironment.Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y - Dropping test database...Success. - Removing privileges on test database...Success.Reloading the privilege tables will ensure that all changesmade so far will take effect immediately.Reload privilege tables now? (Press y|Y for Yes, any other key for No) : ySuccess.All done! lihan@LideMacBook-Air ~ % mysql -u root -pEnter password: Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 11Server version: 8.0.26 HomebrewCopyright (c) 2000, 2021, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.mysql&gt; exit;Bye</code></pre></div><p><strong>建立数据库</strong></p><div class="code-wrapper"><pre><code class="hljs no">链接：https://pan.baidu.com/s/1xDsDWFLiRITYTT6HoFb7Tw 提取码：s5iz</code></pre></div><p>注意存放位置如果有中文路径可能会在之后报<code>error 2</code>错误</p><p>在<code>source</code>后直接拖入<code>sql</code>文件即可</p><div class="code-wrapper"><pre><code class="hljs no">mysql&gt; create database mydatabase;Query OK, 1 row affected (0.01 sec)mysql&gt; use mydatabaseDatabase changedmysql&gt; source /Users/lihan/Desktop/summer/create-databases.sql Query OK, 0 rows affected, 1 warning (0.00 sec)....mysql&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mydatabase         || mysql              || performance_schema || sql_hr             || sql_inventory      || sql_invoicing      || sql_store          || sys                |+--------------------+9 rows in set (0.00 sec)mysql&gt; drop database mydatabase;Query OK, 0 rows affected (0.01 sec)</code></pre></div><h1 id="单表检索"><a href="#单表检索" class="headerlink" title="单表检索"></a>单表检索</h1><ul><li>Mysql大小写不分，建议大写关键字，小写其他内容</li><li>在行前使用<code>--</code>表示注释</li><li>每个语句后使用<code>;</code>表示结束</li><li>可以使用算术表达式</li><li>可以使用<code>AS</code>关键字为列取别名</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, point <span class="hljs-operator">*</span> <span class="hljs-number">10</span> <span class="hljs-operator">+</span> <span class="hljs-number">100</span> <span class="hljs-keyword">AS</span> `discount_factor`<span class="hljs-keyword">FROM</span> customers<span class="hljs-comment">-- WHERE custom_id = 1</span><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> first_name;</code></pre></div><ul><li><code>DISTINCT</code>可以删除重复项， <em>重复</em>是以列的组合判断的，<code>DISTINCT</code>必须放在开头</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> state <span class="hljs-keyword">FROM</span> customers;</code></pre></div><ul><li><code>WHERE</code>中对于文本需要使用单引号或双引号，文本大小写不敏感</li><li>注意此处的<code>Customers</code>与<code>va</code>均大小写不敏感</li><li><code>!=</code> ，<code>&lt;&gt;</code>均意为不等于</li><li>日期类型数据也需使用引号</li><li>可以使用<code>AND</code>，<code>OR</code>，<code>NOT</code>创建复合条件语句</li><li>条件语句中可以使用算数表达式</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> Customers<span class="hljs-keyword">WHERE</span> state <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;va&#x27;</span> <span class="hljs-keyword">AND</span> birth_data <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;1990-01-01&#x27;</span>;</code></pre></div><ul><li><code>IN</code>关键字判断是否在集合中</li><li><code>BETWEEN</code>关键字判断是否在闭区间内</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> customers<span class="hljs-keyword">WHERE</span> state <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;VA&#x27;</span>, <span class="hljs-string">&#x27;FL&#x27;</span>) <span class="hljs-keyword">AND</span> points <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1000</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">2000</span>;</code></pre></div><ul><li><code>LIKE</code>关键字用于文本模糊匹配常用的有：<code>_</code>单一字符，<code>%</code>任意数目字符</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> customers<span class="hljs-keyword">WHERE</span> last_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%field%&#x27;</span>;</code></pre></div><ul><li><code>REGEXP</code>关键字使用正则表达式进行模糊匹配</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> customers<span class="hljs-keyword">WHERE</span> last_name REGEXP <span class="hljs-string">&#x27;field&#x27;</span>;</code></pre></div><ul><li><code>NULL</code>表示空值</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> customers<span class="hljs-keyword">WHERE</span> phone <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;</code></pre></div><ul><li>结果集默认以主键为标准进行生序排序，使用<code>ORDER BY</code>关键字可以使用其他列为标准排序</li><li>默认升序排序，使用<code>DESC</code>进行降序排序</li><li>可以使用多个排序规则，越靠前优先级越高</li><li>Mysql中允许用于排序的列不是结果集的列</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name<span class="hljs-keyword">FROM</span> customers<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> state <span class="hljs-keyword">DESC</span>, first_name <span class="hljs-keyword">DESC</span>;</code></pre></div><ul><li><code>LIMIT</code>关键字用于限制结果集大小，可用于网站分页</li><li><code>LIMIT 3</code>代表结果集大小为3，<code>LIMIT 6, 3</code>代表跳过6行取3行</li><li>注意<code>WHERE</code>，<code>ORDER BY</code>，<code>LIMIT</code>在语句中出现的先后顺序</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> customers<span class="hljs-keyword">WHERE</span> state <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;va&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> points <span class="hljs-keyword">DESC</span>LIMIT <span class="hljs-number">3</span>;</code></pre></div><h1 id="多表检索"><a href="#多表检索" class="headerlink" title="多表检索"></a>多表检索</h1><ul><li><code>JOIN</code>默认代表内连接即 <code>INNER JOIN</code></li><li>可以为表取别名</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> o.customer_id<span class="hljs-keyword">FROM</span> orders o<span class="hljs-keyword">JOIN</span> customers <span class="hljs-keyword">ON</span> o.customer_id <span class="hljs-operator">=</span> customer.customer_id;</code></pre></div><ul><li>可以对不同数据库的表进行连接</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> order_items oi<span class="hljs-keyword">JOIN</span> sql_inventory.products p <span class="hljs-keyword">ON</span> oi.product_id <span class="hljs-operator">=</span> p.product_id;</code></pre></div><ul><li>表也可以与自身进行连接，称为自连接</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.employee_id, e.first_name, m.first_nam<span class="hljs-keyword">FROM</span> employees e<span class="hljs-keyword">JOIN</span> employees m <span class="hljs-keyword">WHERE</span> e.reports_to <span class="hljs-operator">=</span> m.employee_id;</code></pre></div><ul><li><code>JOIN</code>多次使用可以多表连接</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o<span class="hljs-keyword">JOIN</span> customers c<span class="hljs-keyword">ON</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id<span class="hljs-keyword">JOIN</span> order_statuses os<span class="hljs-keyword">ON</span> o.status <span class="hljs-operator">=</span> os.order_status_id;</code></pre></div><ul><li><code>AND</code>创建复合连接条件</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> order_items oi<span class="hljs-keyword">JOIN</span> order_items_notes oin<span class="hljs-keyword">ON</span> oi.order_id <span class="hljs-operator">=</span> oin.order_id<span class="hljs-keyword">AND</span> oi.product_id <span class="hljs-operator">=</span> oin.product_id;</code></pre></div><ul><li>一般我们使用显式连接（第一句）而不是隐式连接（第二句）</li><li>显式连接不加<code>ON</code>指名连接条件或隐式连接不加<code>WHERE</code>，的时候称为交叉连接，返回笛卡尔积的结果</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o<span class="hljs-keyword">JOIN</span> customers c<span class="hljs-keyword">ON</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o, customers c<span class="hljs-keyword">WHERE</span> o.customer_id <span class="hljs-operator">=</span> c.customer_id;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o, customers c;</code></pre></div><ul><li><code>LEFT JOIN</code>左外连接表示所有左表的记录都会返回，如果右表没有相匹配的结果，对应位置置为NULL</li><li><code>OUTER</code>关键字一般省去</li><li>为使得语句清晰，外连接尽量使用左连接</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> customers c<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> orders o<span class="hljs-keyword">ON</span> c.customer_id <span class="hljs-operator">=</span> o.customer_id;</code></pre></div><ul><li>多表连接时候，判断左右表关系似乎是按照<code>ON</code>来的，有待补充</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> customers c<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> orders o<span class="hljs-keyword">ON</span> c.customer_id <span class="hljs-operator">=</span> o.customer_id<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> shippers sh<span class="hljs-keyword">ON</span> o.shipper_id <span class="hljs-operator">=</span> sh.shipper_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> c.customer_id;</code></pre></div><ul><li>和内连接类似，外连接也可以自连接</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> employees m<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> emplyees m<span class="hljs-keyword">ON</span> e.reports_to <span class="hljs-operator">=</span> m.emplyee_id;</code></pre></div><ul><li>当两个表的列名完全一样时，使用<code>USING</code>简化，<code>USING</code>同样适用于有多个列作为键码的情况</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o<span class="hljs-keyword">JOIN</span> customers c<span class="hljs-comment">-- ON o.customer_id = c.customer_id</span><span class="hljs-keyword">USING</span> (customer_id);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> order_items oi<span class="hljs-keyword">JOIN</span> order_items_notes oin<span class="hljs-comment">-- ON oi.order_id = oin.order_id</span><span class="hljs-comment">-- AND oi.product_id = oin.product_id;</span><span class="hljs-keyword">USING</span> (order_id, product_id);</code></pre></div><ul><li><code>NATURAL JOIN</code>自然连接，使用同名的属性组，并且在结果中把重复的属性列去掉，不建议使用</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o<span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> customers c;</code></pre></div><ul><li><code>CROSS JOIN</code>交叉连接，返回笛卡尔积，即所有的组合结果</li><li>第一句为显式写法，第二句为隐式写法</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o<span class="hljs-keyword">CROSS</span> <span class="hljs-keyword">JOIN</span> customers c;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> orders o, customers c;</code></pre></div><ul><li><code>UNION</code>联合查询结果，两次<code>SELECT</code>必须有相同的属性数，属性名以第一次查询为主进行整合</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name<span class="hljs-keyword">FROM</span> archived_orders<span class="hljs-keyword">UNION</span><span class="hljs-keyword">SELECT</span> name<span class="hljs-keyword">FROM</span> orders;</code></pre></div><h1 id="插入、更新、删除"><a href="#插入、更新、删除" class="headerlink" title="插入、更新、删除"></a>插入、更新、删除</h1><ul><li><code>INSERT INTO</code>插入单行</li><li><code>DEFAULT</code>可用于存在默认值或递增的属性</li><li><code>NULL</code>可用于允许空值的属性</li><li>可以指定要插入的列</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> customers<span class="hljs-keyword">VALUES</span> (  <span class="hljs-keyword">DEFAULT</span>,   <span class="hljs-string">&#x27;John&#x27;</span>,   <span class="hljs-string">&#x27;Smith&#x27;</span>,   <span class="hljs-keyword">NULL</span>,<span class="hljs-string">&#x27;address&#x27;</span>,<span class="hljs-string">&#x27;city&#x27;</span>,<span class="hljs-string">&#x27;CA&#x27;</span>,<span class="hljs-number">200</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> customers (first_name,last_name,birth_date,address,city,state)<span class="hljs-keyword">VALUES</span> (  <span class="hljs-string">&#x27;John&#x27;</span>,   <span class="hljs-string">&#x27;Smith&#x27;</span>,   <span class="hljs-string">&#x27;1990-01-01&#x27;</span>,<span class="hljs-string">&#x27;address&#x27;</span>,<span class="hljs-string">&#x27;city&#x27;</span>,<span class="hljs-string">&#x27;CA&#x27;</span>);</code></pre></div><ul><li>使用<code>VALUES</code>也可以一次插入多行</li><li>在删除一些行的情况下，自增的属性值依然会记住他们，即出现递增属性不连续</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> shippers (name)<span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Shipper1&#x27;</span>), (<span class="hljs-string">&#x27;Shipper2&#x27;</span>), (<span class="hljs-string">&#x27;Shipper3&#x27;</span>);</code></pre></div><ul><li><code>LAST_INSERT_TO()</code>获得最新执行成功的<code>INSERT</code>语句的自增id</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> orders (customer_id, order_date, status)<span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2019-01-01&#x27;</span>, <span class="hljs-number">1</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> order_items<span class="hljs-keyword">VALUES</span>     (last_insert_id(), <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2.5</span>),    (last_insert_id(), <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1.5</span>);</code></pre></div><ul><li><code>CREATE TABLE</code>可以通过<code>SELECT</code>语句创建基于查询的复制表，属性不再拥有自增，主键等性质</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> orders_archived <span class="hljs-keyword">AS</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> orders;</code></pre></div><ul><li><code>UPDATE</code>关键字可用于更新表中的某些行</li></ul><div class="code-wrapper"><pre><code class="hljs sql">UPDATE invoices<span class="hljs-keyword">SET</span> payment_total <span class="hljs-operator">=</span> <span class="hljs-number">0.5</span> <span class="hljs-operator">*</span> invoice_total,     payment_date <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2019-01-01&#x27;</span><span class="hljs-keyword">WHERE</span> invoice_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;</code></pre></div><ul><li><code>UPDATE</code>操作也可以结合子查询使用</li><li>子查询添加括号确保先执行</li><li>子查询返回多个数据时应使用<code>IN</code>关键字</li></ul><div class="code-wrapper"><pre><code class="hljs sql">UPDATE invoices<span class="hljs-keyword">SET</span> payment_total <span class="hljs-operator">=</span> <span class="hljs-number">567</span>, payment_date <span class="hljs-operator">=</span> due_date<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span>             (<span class="hljs-keyword">SELECT</span> client_id             <span class="hljs-keyword">FROM</span> clients            <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Yadel&#x27;</span>);UPDATE invoices<span class="hljs-keyword">SET</span> payment_total <span class="hljs-operator">=</span> <span class="hljs-number">567</span>, payment_date <span class="hljs-operator">=</span> due_date<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-keyword">IN</span>             (<span class="hljs-keyword">SELECT</span> client_id             <span class="hljs-keyword">FROM</span> clients            <span class="hljs-keyword">WHERE</span> state <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;CA&#x27;</span>, <span class="hljs-string">&#x27;NY&#x27;</span>));</code></pre></div><ul><li><code>DELETE</code>关键字用于删除</li><li><code>WHERE</code>可选，省略将删除表的所有记录</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span>             (<span class="hljs-keyword">SELECT</span> client_id              <span class="hljs-keyword">FROM</span> clients            <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Myworks&#x27;</span>);</code></pre></div><h1 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h1><ul><li>Mysql内置有<code>MAX()</code>，<code>MIN()</code>，<code>AVG()</code>，<code>SUM()</code>，<code>COUNT()</code>等聚合函数</li><li>聚合函数不仅可以用于列，也可以用于表达式</li><li>聚合函数会忽略空值，对于<code>COUNT()</code>函数需要注意</li><li><code>COUNT(*)</code>不会忽略空值，<code>*</code>表示全部数据</li><li>可以使用<code>DISTINCT</code>筛掉列的重复值</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     <span class="hljs-built_in">MAX</span>(invoice_date) <span class="hljs-keyword">AS</span> latest_date,      <span class="hljs-built_in">MIN</span>(invoice_total) lowest,    <span class="hljs-built_in">AVG</span>(invoice_total) average,    <span class="hljs-built_in">SUM</span>(invoice_total <span class="hljs-operator">*</span> <span class="hljs-number">1.1</span>) total,    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) total_records,    <span class="hljs-built_in">COUNT</span>(invoice_total) number_of_invoices,     <span class="hljs-built_in">COUNT</span>(payment_date) number_of_payments,      <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> client_id) number_of_distinct_clients<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> invoice_date <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2019-07-01&#x27;</span>;</code></pre></div><ul><li><code>GROUP BY</code>配合聚合函数使用，进行分组统计</li><li>注意<code>WHERE</code>，<code>GROUP BY</code>，<code>ORDER BY</code>的先后顺序</li><li><code>GROUP BY</code>也可以多列组合为依据分组，逗号分隔即可</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     client_id,      <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> invoice_date <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2019-07-01&#x27;</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> total_sales <span class="hljs-keyword">DESC</span>;<span class="hljs-keyword">SELECT</span>     state,    city,    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">JOIN</span> clients <span class="hljs-keyword">USING</span> (client_id) <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> state, city  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> state;</code></pre></div><ul><li><code>HAVING</code>关键字对<code>SELECT</code>后的结果列进行事后筛选，通常用于分组聚合后查询</li><li><code>HAVING</code>和 <code>WHERE</code> 都是是条件筛选语句，条件写法相通</li><li><code>HAVING</code>使用结果列明，<code>WHERE</code>使用原表列名</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     client_id,    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales,    <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span><span class="hljs-operator">/</span>invoice_total<span class="hljs-operator">/</span>invoice_date) <span class="hljs-keyword">AS</span> number_of_invoices<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id<span class="hljs-keyword">HAVING</span> total_sales <span class="hljs-operator">&gt;</span> <span class="hljs-number">500</span> <span class="hljs-keyword">AND</span> number_of_invoices <span class="hljs-operator">&gt;</span> <span class="hljs-number">5</span>;</code></pre></div><ul><li>Mysql提供了<code>ROLLUP</code>运算符对聚合值进行汇总，如下将返回各客户的发票总额以及所有人的总发票额</li><li><code>ROLLUP</code>不是标准的SQL语言</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     client_id,    <span class="hljs-built_in">SUM</span>(invoice_total)<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>;</code></pre></div><ul><li>当<code>GROUP BY</code>取多列时，<code>ROLLUP</code>可以进行多层汇总</li><li>下面将返回各州的各市的发票总额以及州层次和全国层次的汇总额</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     state,    city,    <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">AS</span> total_sales<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">JOIN</span> clients <span class="hljs-keyword">USING</span> (client_id) <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> state, city <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>;</code></pre></div><ul><li>使用<code>ROLLUP</code>时，<code>GROUP BY</code>不能使用列别名</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     pm.name <span class="hljs-keyword">AS</span> payment_method,    <span class="hljs-built_in">SUM</span>(amount) <span class="hljs-keyword">AS</span> total<span class="hljs-keyword">FROM</span> payments p<span class="hljs-keyword">JOIN</span> payment_methods pm    <span class="hljs-keyword">ON</span> p.payment_method <span class="hljs-operator">=</span> pm.payment_method_id<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> pm.name <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>;</code></pre></div><h1 id="编写复杂查询"><a href="#编写复杂查询" class="headerlink" title="编写复杂查询"></a>编写复杂查询</h1><ul><li>Mysql将先执行括号内的子查询，之后将结果返回给外查询</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> products<span class="hljs-keyword">WHERE</span> unit_price <span class="hljs-operator">&gt;</span> (    <span class="hljs-keyword">SELECT</span> unit_price    <span class="hljs-keyword">FROM</span> products    <span class="hljs-keyword">WHERE</span> product_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> products<span class="hljs-keyword">WHERE</span> product_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> product_id    <span class="hljs-keyword">FROM</span> order_items);</code></pre></div><ul><li>子查询将一张表的查询结果作为另一张表的查询依据并层层嵌套；链接将这些表合并成一个包含所需全部信息的详情表再直接在详情表里筛选查询；两种方法一般是可互换的，具体用哪一种取决于效率和可读性</li><li>例：查找从未订购过的顾客，下面两种方法均可达到效果</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> clients<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> client_id    <span class="hljs-keyword">FROM</span> invoices);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> clients<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> invoices <span class="hljs-keyword">USING</span> (client_id)<span class="hljs-keyword">WHERE</span> invoices_id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;</code></pre></div><ul><li>例：选出买过生菜（id = 3）的顾客的id，姓和名，采用混合子查询+表连接的方法</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> customer_id, first_name, last_name<span class="hljs-keyword">FROM</span> customers<span class="hljs-keyword">WHERE</span> customer_id <span class="hljs-keyword">IN</span> (      <span class="hljs-keyword">SELECT</span> customer_id    <span class="hljs-keyword">FROM</span> orders    <span class="hljs-keyword">JOIN</span> order_items <span class="hljs-keyword">USING</span> (order_id)      <span class="hljs-keyword">WHERE</span> product_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>);</code></pre></div><ul><li><code>ALL</code>关键字代表集合中的任意记录</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> invoice_total <span class="hljs-operator">&gt;</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(invoice_total)    <span class="hljs-keyword">FROM</span> invoices    <span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> invoice_total <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ALL</span> (    <span class="hljs-keyword">SELECT</span> invoice_total    <span class="hljs-keyword">FROM</span> invoices    <span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>);</code></pre></div><ul><li><code>ANY</code>关键字代表集合中存在某条记录，可与<code>MIN</code>等效</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> invoice_total <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ANY</span> (<span class="hljs-keyword">SELECT</span> invoice_total<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> invoice_total <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MIN</span>(invoice_total)<span class="hljs-keyword">FROM</span> invoices<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> <span class="hljs-number">3</span>);</code></pre></div><ul><li><code>ANY</code>某些时候也可与<code>IN</code>等效</li><li>例：选择至少有两次发票记录的顾客</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> clients<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> client_id    <span class="hljs-keyword">FROM</span> invoices    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span>);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> clients<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> <span class="hljs-keyword">ANY</span> (     <span class="hljs-keyword">SELECT</span> client_id    <span class="hljs-keyword">FROM</span> invoices    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> client_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span>);</code></pre></div><ul><li>在上面的子查询中，子查询与主查询无关，可以先进行完子查询，再进行主查询</li><li>相关子查询，子查询与主查询有关</li><li>例：返回各部门中工资超过该部门平均值的人，对于<code>employees e</code>中的每条记录，都将执行一次子查询</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> employees e  <span class="hljs-comment">-- 关键 1</span><span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(salary)    <span class="hljs-keyword">FROM</span> employees    <span class="hljs-keyword">WHERE</span> office_id <span class="hljs-operator">=</span> e.office_id  <span class="hljs-comment">-- 关键 2</span>    <span class="hljs-comment">-- 【子查询表字段不用加前缀，主查询表的字段要加前缀，以此区分】</span>);</code></pre></div><ul><li><code>EXISTS</code>关键字如果集合不为空返回<code>TRUE</code>，否则返回<code>FALSE</code></li><li><code>IN + 子查询</code> 等效于 <code>EXIST + 相关子查询</code>，如前者子查询结果集过大占用内存，后者逐条验证更有效率</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> clients<span class="hljs-keyword">WHERE</span> client_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> client_id    <span class="hljs-keyword">FROM</span> invoices);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> clients c<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>    <span class="hljs-comment">-- 就这个子查询的目的来说，SELECT的选择不影响结果，</span>    <span class="hljs-comment">-- 因为EXISTS()函数只根据是否为空返回结果</span>    <span class="hljs-keyword">FROM</span> invoices    <span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> c.client_id);</code></pre></div><ul><li><code>EXISTS()</code>返回的是 <code>TRUE/FALSE</code>，所以也可以加上<code>NOT</code>取反</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> product_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">FROM</span> order_items);<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> products p<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>    <span class="hljs-keyword">FROM</span> order_items    <span class="hljs-keyword">WHERE</span> product_id <span class="hljs-operator">=</span> p.product_id);</code></pre></div><ul><li>例：经典题目，选择没有选所有课的学生</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 选择没有选所有课的学生</span><span class="hljs-comment">-- 存在某一样课，该学生没有对应的选课记录</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> stu s<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span>(  <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>  <span class="hljs-keyword">FROM</span> class c  <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>(      <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>      <span class="hljs-keyword">FROM</span> stu_class      <span class="hljs-keyword">WHERE</span> stu_id <span class="hljs-operator">=</span> s.stu_id <span class="hljs-keyword">AND</span> class_id <span class="hljs-operator">=</span> c.class_id    ));</code></pre></div><ul><li>子查询或相关子查询也可用于<code>SELECT</code>中</li><li>引用同级的列别名，需要使用<code>SELECT</code>，引用同级的列别名不需要说明来源</li><li>下面的例子中有三个子查询，第一个为相关子查询，表示某顾客订单总量，第二个为子查询，表示所有订单平均值，第三个引用同级的列别名，表示前两者的差</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span>     client_id,    name,    (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">FROM</span> invoices <span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> c.client_id) <span class="hljs-keyword">AS</span> total_sales,    (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(invoice_total) <span class="hljs-keyword">FROM</span> invoices) <span class="hljs-keyword">AS</span> average,    (<span class="hljs-keyword">SELECT</span> total_sales <span class="hljs-operator">-</span> average) <span class="hljs-keyword">AS</span> difference   <span class="hljs-keyword">FROM</span> clients c;</code></pre></div><ul><li>子查询也可用于<code>FROM</code>中</li><li>当子查询太复杂时应使用视图将子查询结果储存起来，使用视图作为来源表</li><li>在FROM中使用子查询，即使用 “派生表” 时，必须给派生表取个别名</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> (    <span class="hljs-keyword">SELECT</span>         client_id,        name,        (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(invoice_total) <span class="hljs-keyword">FROM</span> invoices <span class="hljs-keyword">WHERE</span> client_id <span class="hljs-operator">=</span> c.client_id) <span class="hljs-keyword">AS</span> total_sales,        (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(invoice_total) <span class="hljs-keyword">FROM</span> invoices) <span class="hljs-keyword">AS</span> average,        (<span class="hljs-keyword">SELECT</span> total_sales <span class="hljs-operator">-</span> average) <span class="hljs-keyword">AS</span> difference       <span class="hljs-keyword">FROM</span> clients c) <span class="hljs-keyword">AS</span> sales_summury<span class="hljs-keyword">WHERE</span> total_sales <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;</code></pre></div><h1 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h1><p>内置的用来处理数值、文本、日期等的函数</p><ul><li>数值函数</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ROUND(<span class="hljs-number">5.7365</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">-- 四舍五入</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">TRUNCATE</span>(<span class="hljs-number">5.7365</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">-- 截断</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CEILING</span>(<span class="hljs-number">5.2</span>)  <span class="hljs-comment">-- 天花板函数，大于等于此数的最小整数</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">5.6</span>)  <span class="hljs-comment">-- 地板函数，小于等于此数的最大整数</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">ABS</span>(<span class="hljs-number">-5.2</span>)  <span class="hljs-comment">-- 绝对值</span><span class="hljs-keyword">SELECT</span> RAND()  <span class="hljs-comment">-- 随机函数，0到1的随机值</span></code></pre></div><ul><li>字符串函数</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> LENGTH(<span class="hljs-string">&#x27;sky&#x27;</span>)  <span class="hljs-comment">-- 字符串字符个数</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">UPPER</span>(<span class="hljs-string">&#x27;sky&#x27;</span>)  <span class="hljs-comment">-- 转大写</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">LOWER</span>(<span class="hljs-string">&#x27;Sky&#x27;</span>)  <span class="hljs-comment">-- 转小写</span><span class="hljs-keyword">SELECT</span> LTRIM(<span class="hljs-string">&#x27;  Sky&#x27;</span>)  <span class="hljs-comment">-- 去除左多余空格</span><span class="hljs-keyword">SELECT</span> RTRIM(<span class="hljs-string">&#x27;Sky  &#x27;</span>)  <span class="hljs-comment">-- 去除右多余空格</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">TRIM</span>(<span class="hljs-string">&#x27; Sky &#x27;</span>)  <span class="hljs-comment">-- 去除多余空格</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">LEFT</span>(<span class="hljs-string">&#x27;Kindergarden&#x27;</span>, <span class="hljs-number">4</span>)  <span class="hljs-comment">-- 取左4个字符</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">RIGHT</span>(<span class="hljs-string">&#x27;Kindergarden&#x27;</span>, <span class="hljs-number">6</span>)  <span class="hljs-comment">-- 取右6个字符</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUBSTRING</span>(<span class="hljs-string">&#x27;Kindergarden&#x27;</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>)  <span class="hljs-comment">-- 从第7个开始长度为6的子串，省略长度参数则取到末端</span><span class="hljs-keyword">SELECT</span> LOCATE(<span class="hljs-string">&#x27;gar&#x27;</span>, <span class="hljs-string">&#x27;Kindergarden&#x27;</span>)  <span class="hljs-comment">-- 定位首次出现的位置，没有的话返回0，不区分大小写</span><span class="hljs-keyword">SELECT</span> REPLACE(<span class="hljs-string">&#x27;Kindergarten&#x27;</span>, <span class="hljs-string">&#x27;garten&#x27;</span>, <span class="hljs-string">&#x27;garden&#x27;</span>)  <span class="hljs-comment">-- 替换</span><span class="hljs-keyword">SELECT</span> CONCAT(f_name, <span class="hljs-string">&#x27; &#x27;</span>, l_name) <span class="hljs-keyword">AS</span> f_name <span class="hljs-keyword">FROM</span> customers  <span class="hljs-comment">-- 连接</span></code></pre></div><ul><li>处理时间日期的函数</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 当前时间日期对象</span><span class="hljs-keyword">SELECT</span> NOW()  <span class="hljs-comment">-- 2021-08-27 08:50:46</span><span class="hljs-keyword">SELECT</span> CURDATE()  <span class="hljs-comment">-- 2021-08-27</span><span class="hljs-keyword">SELECT</span> CURTIME()  <span class="hljs-comment">-- 08:50:46</span><span class="hljs-comment">-- 提取时间日期对象中的元素</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">YEAR</span>(NOW())  <span class="hljs-comment">-- 2021</span><span class="hljs-keyword">SELECT</span> DAYNAME(NOW())  <span class="hljs-comment">-- Saturday</span><span class="hljs-keyword">SELECT</span> MONTHNAME(NOW())  <span class="hljs-comment">-- September</span></code></pre></div><ul><li>日期格式化，格式说明符里，大小写是不同的，这是目前SQL里第一次出现大小写不同的情况</li></ul><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATE_FORMAT(NOW(), <span class="hljs-string">&#x27;%M %d, %Y&#x27;</span>)  <span class="hljs-comment">-- September 12, 2020</span><span class="hljs-keyword">SELECT</span> TIME_FORMAT(NOW(), <span class="hljs-string">&#x27;%H:%i %p&#x27;</span>)  <span class="hljs-comment">-- 11:07 AM</span></code></pre></div><h1 id="SELECT-语句执行顺序"><a href="#SELECT-语句执行顺序" class="headerlink" title="SELECT 语句执行顺序"></a>SELECT 语句执行顺序</h1><p>其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，只有最后一个虚拟的表才会被作为结果返回。 </p><ol><li>FORM：对表计算笛卡尔积，产生虚表VT1。</li><li>ON：对虚表VT1进行ON筛选，只有那些符合<code>join-condition</code>的行才会被记录在虚表VT2中。</li><li>JOIN：如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, 如果from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li><li>WHERE：对虚拟表VT3进行WHERE条件过滤。只有符合<code>where-condition</code>的记录才会被插入到虚拟表VT4中。</li><li>GROUP BY：根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5。</li><li>HAVING：对虚拟表VT5应用having过滤，只有符合<code>having-condition</code>的记录才会被插入到虚拟表VT6中。</li><li>SELECT：执行select操作，选择指定的列，插入到虚拟表VT7中。</li><li>DISTINCT：对VT7中的记录进行去重。产生虚拟表VT8。</li><li>ORDER BY: 将虚拟表VT8中的记录按照<order_by_list>进行排序操作，产生虚拟表VT9。</li><li>LIMIT：取出指定行的记录，产生虚拟表VT10,并将结果返回。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1UE41147KC?p=34">伟大的海伦君.SQL进阶教程</a></p><p><a href="https://zhuanlan.zhihu.com/p/222865842">ASC2050.Mosh完全掌握SQL笔记</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络面试</title>
    <link href="/2021/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>通过光缆、电缆、双绞线、无线电波等方式将电脑连接起来，将数据包转化为0和1的电信号进行传输，主要规定网络的一些电气特性。</p><h2 id="链接层"><a href="#链接层" class="headerlink" title="链接层"></a>链接层</h2><p>链接层规定了0和1的分组方式，即如何解读获得的01串。</p><p class="note note-primary">  <b>以太网协议</b></p><p>以太网协议规定，一组电信号构成一个数据包：“帧”，每一帧包括标头（Head）和数据（Data）。</p><p>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p><p>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p><p class="note note-primary">  <b>MAC地址</b></p><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，叫做MAC地址。</p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示，如<code>00-B0-D0-86-BB-F7</code>，前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><p class="note note-primary">  <b>广播</b></p><p>以太网数据包必须知道接收方的MAC地址，然后才能发送，需要用到ARP协议，这个留到后面介绍。</p><p>有了MAC地址后，为了把数据包准确送到接收方，以太网采用了一种很”原始”的方式，它向本网络内所有计算机发送数据包，每台计算机自己判断是否为接收方。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p class="note note-primary">  <b>网络层的由来</b></p><p>互联网是无数子网络共同组成的一个巨型网络，以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。”路由”，就是指如何向不同的子网络分发数据包。遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p><p>这就导致了”网络层”的诞生。它引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</p><p>“网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p><p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p><p class="note note-primary">  <b>IP协议</b></p><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p><p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成，习惯上，我们用分成四段的十进制数表示IP地址，从<code>0.0.0.0</code>一直到<code>255.255.255.255</code>。</p><p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。</p><p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。</p><p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址<code>172.16.254.1</code>，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是<code>255.255.255.0</code>。</p><p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算，如果结果相同的话，就表明它们在同一个子网络中。</p><p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p><p class="note note-primary">  <b>IP数据包</b></p><p>IP数据包在传输过程中会被放到以太网数据包的“数据”部分，分为”标头”和”数据”两个部分。</p><p>“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。</p><p>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此理论上，一个IP数据包的”数据”部分最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p><p class="note note-primary">  <b>ARP协议</b></p><p>在发送方发送数据时，因为IP数据包是放在以太网数据包里发送的，所以我们必须知道对方的MAC地址和对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p><p>所以，我们需要一种机制，能够从IP地址得到MAC地址，这里可以分成两种情况。</p><p>第一种情况，两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p><p>第二种情况，两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是<code>FF:FF:FF:FF:FF:FF</code>，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，做出回复，向对方报告自己的MAC地址。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p class="note note-primary">  <b>传输层的由来</b></p><p>有了MAC地址和IP地址，可以在互联网上任意两台主机上建立通信。</p><p>问题是，同一台主机上有许多进程需要用到网络，也就是说，我们还需要一个参数，表示这个数据包到底供哪个进程使用。这个参数就叫做”端口”（port），它是每一个使用网卡的进程的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>“端口”是0到65535之间的一个整数，16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p><p>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p><p class="note note-primary">  <b>UDP协议</b></p><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p><p>UDP数据包，也是由”标头”和”数据”两部分组成。”标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分。</p><p>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><p class="note note-primary">  <b>TCP协议</b></p><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p><p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p><p>TCP协议并不能够确保数据不会遗失，但是可以确保数据一旦遗失，接收方可以得知这件事。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>“应用层”的作用，就是规定应用程序的数据格式。</p><p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p><p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。</p><p>应用软件在应用层实现，应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的。当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。</p><p>应用层工作在操作系统中的用户态，传输层及以下工作在内核态。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">阮一峰.互联网协议入门(一)</a></p><h1 id="HTTP篇"><a href="#HTTP篇" class="headerlink" title="HTTP篇"></a>HTTP篇</h1><p>HTTP 是超文本传输协议，也就是<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p><h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h2><p>HTTP最早的版本是1991年发布的0.9版本，该版本极为简单，只有一个命令<code>GET</code></p><div class="code-wrapper"><pre><code class="hljs http">GET /index.html</code></pre></div><p>TCP 连接建立后，客户端向服务器请求网页<code>index.html</code>。协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>服务器发送完毕，就关闭TCP连接。</p><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h2><p>1996年5月，HTTP/1.0 版本发布，内容大大增加。</p><p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p><p>其次，除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。</p><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回具体内容，通常只用于读取数据。</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。</td></tr><tr><td>POST</td><td>向指定资源请求数据处理，如提交表单或者上传文件，服务器返回处理结果。数据包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的更改。</td></tr></tbody></table></div><p>再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p><p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p><p class="note note-primary">  <b>请求格式</b></p> <div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/</span> <span class="hljs-meta">HTTP/1.0</span><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)<span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*</code></pre></div><p>一行是请求命令，必须在尾部添加协议版本<code>HTTP/1.0</code>。后面就是多行头信息，描述客户端的情况，其中<code>User-Agent</code> 字段标识了浏览器的身份。</p><p class="note note-primary">  <b>回应格式</b></p> <p>服务器的回应如下</p><div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.0</span> <span class="hljs-number">200</span> OK <span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain<span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>137582<span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Thu, 05 Dec 1997 16:00:00 GMT<span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Wed, 5 August 1996 15:55:28 GMT<span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache 0.84<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre></div><p>回应的格式是”头信息 + 一个空行（<code>\r\n</code>） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p><p class="note note-primary">  <b>Content-Type 字段</b></p> <p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是<code>Content-Type</code>字段的作用。常见的<code>Content-Type</code>字段的值有：text/plain，text/html，text/css，image/jpeg，image/png，image/svg+xml，audio/mp4，video/mp4，application/javascript，application/pdf，application/zip，application/atom+xml等。</p><p>这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。<code>MIME type</code>还可以在尾部使用分号，添加参数。</p><div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8</code></pre></div><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p><p>客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。</p><div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*</code></pre></div><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p><p><code>MIME type</code>还可以用在其他地方，如HTML网页。</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- 等同于 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span></code></pre></div><p class="note note-primary">  <b>Content-Encoding 字段</b></p> <p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。<code>Content-Encoding</code>字段说明数据的压缩方法。</p><div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip<span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>compress<span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>deflate</code></pre></div><p>客户端在请求时，用<code>Accept-Encoding</code>字段说明自己可以接受哪些压缩方法。</p><div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate</code></pre></div><p class="note note-primary">  <b>状态码</b></p> <p>HTTP/1.0 规定，所有HTTP响应的第一行都是<strong>状态行</strong>，依次是当前HTTP版本号，3位数字组成的<a href="https://zh.wikipedia.org/wiki/HTTP状态码">状态代码</a>，以及描述状态的短语，彼此由空格分隔。</p><p>HTTP/1.1 在 1.0 的基础上新增了 24 个错误状态响应码，随着HTTP协议的发展，状态码的种类也在不断扩大中。目前常用的状态码包括以下五类：</p><div class="table-container"><table><thead><tr><th></th><th>描述</th><th>常见状态码</th></tr></thead><tbody><tr><td>1xx消息</td><td>请求已被服务器接收，继续处理</td><td></td></tr><tr><td>2xx成功</td><td>请求已成功被服务器接收、理解、并接受</td><td>200、204、206</td></tr><tr><td>3xx重定向</td><td>需要后续操作才能完成这一请求</td><td>301、302、304</td></tr><tr><td>4xx请求错误</td><td>请求含有词法错误或者无法被执行</td><td>400、403、404</td></tr><tr><td>5xx服务器错误</td><td>服务器在处理某个正确请求时发生错误</td><td>500、501、502、503</td></tr></tbody></table></div><p class="note note-primary">  <b>HTTP/1.0 的缺点</b></p> <p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果请求其他资源，就必须再新建一个连接。</p><p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p><p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。</p><div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive</code></pre></div><p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应<code>Connection: keep-alive</code>。</p><p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年，它进一步完善了 HTTP 协议，增加了六种请求方法：<code>PUT</code>、<code>PATCH</code>、 <code>OPTIONS</code>、<code>DELETE</code>、<code>TRACE</code> 和 <code>CONNECT</code> 。</p><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>PUT</td><td>替换指定的资源，没有的话就新增。</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新。</td></tr><tr><td>OPTIONS</td><td>向服务器发送该方法，会返回对指定资源所支持的 HTTP 请求方法。</td></tr><tr><td>DELETE</td><td>请求服务器删除 URL 标识的资源数据。</td></tr><tr><td>CONNECT</td><td>将服务器作为代理，让服务器代替用户进行访问。</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。</td></tr></tbody></table></div><p class="note note-primary">  <b>持久连接</b></p> <p>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code>。</p><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p><p class="note note-primary">  <b>管道机制</b></p> <p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。</p><p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p><p class="note note-primary">  <b>Content-Length 字段</b></p><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。</p><div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>3495</code></pre></div><p>上面代码告诉浏览器，本次回应的长度是3495个字节，这些字节会被截取作为本次回应。后面的字节作为下一个回应的内容。</p><p class="note note-primary">  <b>分块传输编码</b></p><p>使用<code>Content-Length</code>字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p><p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p><p>因此，1.1版规定可以不使用<code>Content-Length</code>字段，而使用<a href="https://zh.wikipedia.org/wiki/分块传输编码">“分块传输编码”</a>（chunked transfer encoding）。只要请求或回应的头信息有<code>Transfer-Encoding</code>字段，就表明回应将由数量未定的数据块组成。</p><div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked</code></pre></div><p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。</p><div class="code-wrapper"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain<span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<span class="livecodeserver"><span class="hljs-number">25</span></span><span class="livecodeserver">This is <span class="hljs-keyword">the</span> data <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> chunk</span><span class="livecodeserver"></span><span class="livecodeserver"><span class="hljs-number">1</span>C</span><span class="livecodeserver"><span class="hljs-keyword">and</span> this is <span class="hljs-keyword">the</span> <span class="hljs-keyword">second</span> <span class="hljs-literal">one</span></span><span class="livecodeserver"></span><span class="livecodeserver"><span class="hljs-number">3</span></span><span class="livecodeserver">con</span><span class="livecodeserver"></span><span class="livecodeserver"><span class="hljs-number">8</span></span><span class="livecodeserver">sequence</span><span class="livecodeserver"></span><span class="livecodeserver"><span class="hljs-number">0</span></span></code></pre></div><p class="note note-primary">  <b>HOST请求头</b></p><p>早期 HTTP/1.0 中认为每台服务器都绑定一个唯一的 IP 地址并提供单一的服务，请求消息中的 URL 并没有传递主机名。而随着虚拟主机的出现，一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个 IP 地址。</p><p>为了支持虚拟主机，HTTP/1.1 中添加了 host 请求头，如<code>Host: www.example.com</code>，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个 404 错误状态码。</p><p class="note note-primary">  <b>缺点</b></p><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为<a href="https://zh.wikipedia.org/wiki/队头阻塞">“队头堵塞”</a>（Head-of-line blocking）。</p><p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTP 由于是明文传输，所谓的明文，就是说客户端与服务端通信的信息都是肉眼可⻅的，随意使用一个抓包工具都可以截获通信的内容。<br>所以安全上存在以下三个⻛险</p><ul><li><strong>窃听风险</strong>：第三方可以获知通信内容；</li><li><strong>篡改风险</strong>：第三方可以修改通信内容；</li><li><strong>冒充风险</strong>：第三方可以冒充他人身份参与通信。</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加入了SSL/TLS协议，来解决上述的⻛险。</p><ul><li>所有信息都是<strong>加密传播</strong>，第三方无法窃听；</li><li>具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现；</li><li>配备<strong>身份证书</strong>，防止身份被冒充。</li></ul><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记1.png?raw=true" alt=""></p><p>HTTPS经由<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a>进行通信，但利用<a href="https://zh.wikipedia.org/wiki/传输层安全">SSL/TLS</a>来<a href="https://zh.wikipedia.org/wiki/加密">加密</a>数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换资料的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。</p><p>历史上，HTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。在2000年代末至2010年代初，HTTPS开始广泛使用，以确保各类型的网页真实，保护账户和保持用户通信，身份和网络浏览的私密性。</p><p>在真正认识SSL/TLS以前，需要了解一些基础的加密算法知识。</p><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>加密算法分为以下两种：</p><p class="note note-primary">  <b>对称加密</b></p><ul><li><p>甲方选择某一种加密规则，对信息进行加密；乙方使用同一种规则，对信息进行解密；</p></li><li><p>加密和解密使用同样规则（简称”<strong>密钥</strong>“）。</p></li></ul><p>甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。</p><p>后来，人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。</p><p class="note note-primary">  <b>不对称加密</b></p><ul><li>乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的；甲方获取乙方的公钥，然后用它对信息加密。乙方得到加密后的信息，用私钥解密；</li><li>不对称加密又称公钥加密法；</li><li>公钥和私钥是一一对应的关系，用公钥可以解开私钥加密的信息，反之亦成立；</li><li>同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或不可能的；</li><li>在双钥体系中，<strong>公钥用来加密/验签，私钥用来解密/签名</strong>。</li></ul><p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</p><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>不对称加密过程中，双方的通信是建立在公钥可信的基础上的：</p><ol><li>服务器对数据进行Hash生成<strong>摘要</strong>后，使用私钥对摘要进行签名运算生成<strong>数字签名</strong>，服务器将数据和数字签名一同发给客户端；</li><li>客户端对数据进行相同的Hash，并对数字签名使用服务器的公钥解密，如果解密结果与Hash结果相同，则确认为服务器发出。</li></ol><p>如果一开始客户端拿到的公钥就是假的话，那么服务器后来发出的任何内容客户端均无法识别。问题在于客户端获取公钥的过程依然是不安全的，为此提出数字证书的方法，通过可信的第三方证书颁发机构（CA）保证服务器的公钥通过可信的方式传递：</p><ol><li>服务器将自己的公钥及其他相关信息发送给CA，CA核实身份后为其颁发一个数字证书，证书包括服务器公钥，证书办法机构，有效期等数据。同时，CA生成一对公钥私钥，使用私钥对数字证书进行签名，并将签名添加到数字证书中，数字证书 = 服务器公钥等信息 + 这些信息的数字签名；</li><li>客户端系统默认安装了根证书，根证书里记录了可以信赖的CA机构信息及公钥信息，根证书预先安装在系统中杜绝被篡改的可能；</li><li>服务器将数据，数字签名，自身的数字证书一同发送给客户端；</li><li>客户端根据CA的公钥对数字证书中的签名解密，并对数字证书做Hash运算，两者相同则可以确保数字证书的可信性，从证书中拿到服务器的公钥即可进行验签。</li></ol><p><strong>为什么先进行摘要再进行签名？</strong></p><p>原数据过大，加密算法耗时。</p><p><strong>数字签名的作用</strong></p><p>对数据进行校验，并确保数据的发送者。</p><h3 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h3><p>SSL/TLS协议的基本思路是采用<a href="https://en.wikipedia.org/wiki/Public-key_cryptography">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p>但是，这里有个问题：公钥加密计算量太大，如何减少耗用的时间？</p><p>采用<strong>混合加密</strong>。每一次对话，客户端和服务器端都生成一个”<strong>对话密钥</strong>“，用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p><p>因此，SSL/TLS协议的基本过程是这样的：</p><ul><li><p>客户端向服务器端索要并验证公钥；</p></li><li><p>双方协商生成”对话密钥”；</p></li><li><p>双方采用”对话密钥”进行加密通信；</p></li></ul><p>上面过程的前两步，又称为”握手阶段”（SSL/TLS握手在TCP握手之后）。</p><h3 id="SSL-TSL握手"><a href="#SSL-TSL握手" class="headerlink" title="SSL/TSL握手"></a>SSL/TSL握手</h3><p>基于RSA加密的握手过程，也是基础的SSL/TSL握手过程。</p><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记2.png?raw=true" alt=""></p><p><strong>1. 客户端发出请求（ClientHello）</strong></p><p>客户端向服务器发出加密通信的请求，称为ClientHello请求，客户端主要向服务器提供以下信息：</p><p class="note note-secondary">  （1）支持的协议版本，比如TLS 1.0版。  <br>  （2）一个客户端生成的随机数Client random，稍后用于生成"对话密钥"。  <br>  （3）支持的加密方法，比如RSA公钥加密。  <br>  （4）支持的压缩方法。</p><p><strong>2. 服务器回应（SeverHello）</strong></p><p>服务器的回应包含以下内容：</p><p class="note note-secondary">  （1）确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。  <br>  （2）一个服务器生成的随机数Server random，稍后用于生成"对话密钥"。  <br>  （3）确认使用的加密方法，比如RSA公钥加密。  <br>  （4）服务器证书。</p><p><strong>3. 客户端回应</strong></p><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p><p class="note note-secondary">  （1）一个随机数。该随机数用服务器公钥加密，防止被窃听。  <br>  （2）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。  <br>  （3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</p><p> 此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p><p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p><p>值得注意的是，该过程之前的阶段均为明文传输；而pre-master key使用服务器公钥加密，之后客户端与服务器端均生成会话密钥，数据传输均为加密传输。</p><p><strong>4. 服务器的最后回应</strong></p><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p><p class="note note-secondary">  （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。  <br>  （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</p><p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p><p>使用 RSA密钥协商算法的最大问题是不支持前向保密。整个握手阶段都不加密（也没法加密），都是明文的。如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。所以一旦服务端的私钥泄漏 了，过去被第三方截获的所有 TLS 通讯密文都会被破解。所以目前使用较多的为<strong>ECDHE加密法</strong>。</p><h3 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h3><p><strong>离散对数</strong></p><p>假定 a, p 均是素数，下面两个集合相等，证明过程请参考 <a href="http://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0133354695">Cryptography and Network Security</a> 第八章：</p><div class="code-wrapper"><pre><code class="hljs no">&#123; a^1 mod p, a^2 mod p, ..., a^(p-1) mod p &#125; = &#123;1, 2, ... , p-1 &#125;   &#123;&#125; 表示集合</code></pre></div><p>上述式子可概括成以下三点，对于 1 &lt;= x,y &lt;= p - 1，有：</p><ul><li>a^x mod p 一定属于 {1, 2, …, p -1 }</li><li>如果 x != y，则 a^x mod p != a^y mod p</li><li>对于 1 &lt;= b &lt;= p - 1，一定存在唯一的 1 &lt;= x &lt;= p-1，使得 b = a^x mod p</li></ul><p>第三点在求解上有这么一个特点：已知 x 求 b 非常容易，已知 b 求 x 非常困难，特别当 p 很大时，求解的复杂度非常高，所以它又被称为离散对数问题 (<a href="https://en.wikipedia.org/wiki/Discrete_logarithm">Discrete logarithm</a>)，它是 DH 算法能够安全交换密钥的基础</p><p><strong>求模公式</strong></p><p>假设 q 为素数，对于正整数 a,x,y，有：</p><div class="code-wrapper"><pre><code class="hljs no">(a^x mod p)^y mod p = a^(xy) mod p</code></pre></div><p>证明如下：</p><div class="code-wrapper"><pre><code class="hljs no">令 a^x = mp + n， 其中 m, n 为自然数， 0 &lt;= n &lt; p，则有C = (a^x mod p)^y mod p  = ((mp + n) mod p)^y mod p  = n^y mod p  = (mp +n)^y mod p  = a^(xy) mod p</code></pre></div><p><strong>Deffie-Hellman 算法</strong></p><ol><li>首先 A, B 共同选取 p 和 a 两个素数，p 和 a 均公开；</li><li>之后 A 选择一个自然数 Xa &lt; p，计算出 Ya = a^Xa mod p，Xa 保密，Ya 公开；</li><li>同理，B 选择 Xb &lt; p 并计算出 Yb = a^Xb mod p，其中 Xb 保密，Yb 公开；</li><li>A 用 Yb 和 Xa 计算出密钥 K = Yb^Xa mod p，而 B 用 Ya 和 Xb 计算密钥 K = Ya^Xb mod p。</li></ol><p>流程如下：</p><div class="code-wrapper"><pre><code class="hljs no">+-------------------------------------------------------------------+|                    Global Pulic Elements                          ||                                                                   ||       p                               prime number                ||       a                               prime number, a &lt; p         |+-------------------------------------------------------------------++-------------------------------------------------------------------+|                    User A Key Generation                          ||                                                                   ||       Select private Xa               Xa &lt; p                      ||       Calculate public Ya             Ya = a^Xa mod p             |+-------------------------------------------------------------------++-------------------------------------------------------------------+|                    User B Key Generation                          ||                                                                   ||       Select private Xb               Xb &lt; p                      ||       Calculate public Yb             Yb = a^Xb mod p             |+-------------------------------------------------------------------++-------------------------------------------------------------------+|               Calculation of Secret Key by User A                 ||                                                                   ||       Secret Key K                    K = Yb^Xa mod p             |+-------------------------------------------------------------------++-------------------------------------------------------------------+|               Calculation of Secret Key by User B                 ||                                                                   ||       Secret Key K                    K = Ya^Xb mod p             |+-------------------------------------------------------------------+</code></pre></div><p>下面证明，A 和 B 计算出来的密钥 K 相同。</p><div class="code-wrapper"><pre><code class="hljs no">K = Yb^Xa mod p  = (a^Xb mod p)^Xa mod p  = a^(Xa * Xb) mod p          根据上述求模公式  = (a^Xa mod p)^Xb mod p  = Ya^Xb mod p</code></pre></div><p>上面一共出现了 a, p, Xa, Ya, Xb, Yb, K 共 7 个数，其中：</p><ul><li>公开的数：a, p, Ya, Yb</li><li>非公开数：Xa, Xb, K</li></ul><p>通常情况下，a 一般为 2 或 5，而 p 的取值非常大，至少几百位，Xa 和 Xb 的取值也非常大，其复杂度至少为 <a href="https://en.wikipedia.org/wiki/Pollard&#39;s_rho_algorithm_for_logarithms">O(p^0.5)</a>。对于攻击者来说，已知 Ya，Xa 的求解非常困难，同理 Xb 的求解也很困难，所以攻击者难以求出 K，所以 DH 能够保证通信双方在<strong>透明</strong>的信道中安全的交换密钥。</p><p>DH 算法主要实现方法为<strong>DHE 算法</strong>，DHE 算法让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，E 全称是 ephemeral（临时性的）。这样就保证了 <strong>前向安全</strong>，即使曾经的通信过程被破解，不会影响现在的通信的安全性。</p><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。HTTP/2必须在HTTPS 环境才会生效。</p><p class="note note-primary">  <b>二进制协议</b></p> <p>HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p><p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p><p class="note note-primary">  <b>多工</b></p> <p>HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p><p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。</p><p>这样双向的、实时的通信，就叫做多工（Multiplexing）。</p><p class="note note-primary">  <b>数据流</b></p> <p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p><p>数据流发送到一半的时候，客户端和服务器都可以发送信号（<code>RST_STREAM</code>帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p><p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p><p class="note note-primary">  <b>头信息压缩</b></p> <p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如<code>Cookie</code>和<code>User Agent</code>，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用<code>gzip</code>或<code>compress</code>压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p><p class="note note-primary">  <b>服务器推送</b></p> <p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p><p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p><h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/9453579154e3">creepycool.User-Agent格式含义与示例</a></p><p><a href="https://www.jianshu.com/p/c5cf6a1967d1">狗子渣渣.HTTP请求头之User-Agent</a></p><p><a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">阮一峰.RSA算法原理（一）</a></p><p><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">阮一峰.SSL/TLS协议运行机制的概述</a></p><p><a href="https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">阮一峰.图解SSL/TLS协议</a></p><p><a href="https://juejin.cn/post/6895624327896432654#heading-9">洛禹Keith.TLS 详解握手流程</a></p><p><a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">小林coding.图解 HTTP 常见的面试题</a></p><p><a href="https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">阮一峰.数字签名是什么</a></p><p><a href="http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html">阮一峰.密码学笔记</a></p><p><a href="https://segmentfault.com/a/1190000024523772">编程指北.加密、数字签名和数字证书</a></p><p><a href="https://www.bilibili.com/video/BV18N411X7ty?from=search&amp;seid=14278761812457535723">佳朵.数字签名 及 数字证书 原理</a></p><p><a href="http://wsfdl.com/algorithm/2016/02/04/理解Diffie-Hellman密钥交换算法.html">koala bear.理解 Deffie-Hellman 密钥交换算法</a></p><p><a href="https://www.ruanyifeng.com/blog/2016/08/http.html">阮一峰.HTTP协议入门</a></p><h1 id="TCP篇"><a href="#TCP篇" class="headerlink" title="TCP篇"></a>TCP篇</h1><p>TCP是<code>面向连接</code>的、<code>可靠</code>的、<code>基于字节流</code>的传输层通信协议。</p><h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h2><p>在介绍三次握手，四次挥手的过程之前，需要了解TCP头部的一些知识</p><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记4.png?raw=true" alt=""></p><ul><li><code>源端口</code>和目的端口：确定主机中的进程；</li><li>序号(seq)：报文段中的的第一个数据字节在数据流中的序号，主要用来解决网络报乱序的问题；</li><li>确认号(ack_seq)：所期望收到的下一个数据包的序号；</li><li>ACK：1有效，表示已经收到数据包</li><li>RST：1有效，连接复位请求</li><li>SYN：1有效，表示申请与接收方建立连接</li><li>FIN：1有效，表示申请与接收方断开连接</li></ul><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>网络中A与B要建立TCP连接，可以分为以下四步：</p><div class="code-wrapper"><pre><code class="hljs no">（1）A请求向B发送消息（2）B向A表示同意（3）B请求向A发送消息（4）A向B表示同意</code></pre></div><p>可以发现，由于(2)(3)过程均为B向A发送消息，所以合为一次握手，实际上TCP建立连接只需要三次握手即可。</p><p>接下来介绍三次握手的具体过程</p><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记5.png?raw=true" alt=""></p><p>（1）服务器进程创建传输控制块TCB，准备接受连接请求，进入LISTEN（监听）状态；</p><p>（2）客户端进程创建传输控制块TCB，发送SYN=1，seq初始化为随机值X的连接请求报文段，之后进入SYN_SEND（同步已发送）状态；<br>（3）收到连接请求后，服务器进程向客户端进程发送一个响应+请求报文段，ACK=1，SYN=1，ack_seq=X+1，seq初始化为随机值Y，进入SYN_RCVD（同步收到）状态；<br>（3）客户端进程响应服务器进程的连接请求，向B发送一个ACK=1的报文段，置seq=X+第一次握手报文长度1，ack_seq=Y，之后客户端进程客户端进程进入ESTABLISHED（已建立连接）状态；<br>（4）服务器进程收到客户端进程响应后同样进入ESTABLISHED（已建立连接）状态。</p><p class="note note-primary">  <b>半连接队列与全连接队列</b></p><p>服务器第一次收到客户端的 SYN之后，就会处于 SYN_RCVD状态，此时双方还没有完全建立连接。服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p><p>已经完成三次握手，建立起连接的就会放在全连接队列中。</p><p>如果半连接队列或全连接队列满了就有可能会出现丢包现象。</p><p class="note note-primary">  <b>三次握手可以携带数据吗</b></p><p>第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p><p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，在第一次握手中的 SYN 报文中放入大量的数据，疯狂重复发 SYN 报文，这会让服务器花费大量的内存空间来缓存这些报文。</p><p>对于第三次握手，此时客户端已经处于连接状态，他已经知道服务器的接收、发送能力是正常的了，所以可以携带数据是情理之中。</p><p class="note note-primary">  <b>如果三次握手时每次握手信息对方没有收到</b></p><p>若第一次握手服务器未接收到客户端请求建立连接的数据包，客户端由于在一段时间内没有收到服务器发来的确认报文， 因此会重新发送 SYN 报文，若仍然没有回应，则重复上述过程直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1。</p><p>若第二次握手客户端未接收到服务器回应的 ACK 报文时，客户端会采取第一次握手失败时的动作，而服务器端此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文。</p><p>若第三次握手服务器未接收到客户端发送过来的 ACK 报文，服务器端同样会采取类似于客户端的超时重传机制，若重传次数超过限制后仍然没有回应，则 accep() 系统调用返回 -1，服务器端连接建立失败。但此时客户端认为自己已经连接成功了，因此开始向服务器端发送数据，但是服务器端的 accept() 系统调用已返回，此时没有在监听状态。因此服务器端接收到来自客户端发送来的数据时会发送 RST 报文给 客户端，消除客户端单方面建立连接的状态。</p><p class="note note-primary">  <b>为什么不可以两次握手</b></p><p>三次握手的主要目的是<strong>确认双方的收发能力</strong>。若采用两次握手，客户端能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。但此时服务器并不能确认客户端的接收能力是否正常。</p><p>如果客户端未接收到第二次握手的包，或是客户端收到该包之前已不想建立TCP连接，而服务器并不知情，如果没有第三次握手告诉服务器，服务器端的端口就会一直开着，若客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。这样的端口越来越多，就会造成服务器开销的浪费。</p><p class="note note-primary">  <b>如建立连接后客户端出现故障</b></p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记6.png?raw=true" alt=""></p><p>挥手过程，A与B断开连接之后，B可能还会有需要发个A的数据，不能立刻断开连接，需要有一个CLOSE_WAIT的过程，不能合为三次。</p><p>（1）A将FIN置为1，ACK置为1，seq设置为X=上一次对方传送过来的ack_seq，ack_seq设置为Y=为上一次对方传过来的seq+1。将数据发送至B，然后A进入FIN_WAIT_1状态；<br>（2）B收到了A发送的FIN报文段，向A回复，将ACK置为1，seq设置为Y，ack_seq设置为X+1。然后B进入CLOSE_WAIT状态，A收到B的回复后，进入FIN_WAIT_2状态；<br>（3）B再次向A发送报文，FIN置为1，ACK置为1，seq设置为Y，ack_seq设置为X+1，然后B进入LAST_ACK状态，A收到B的报文后，进入TIME_WAIT状态；<br>（4）A收到B发送的FIN报文段，向B回复，ACK置为1，seq设置为X+1，ack_seq设置为Y+1。然后A进入TIME_WAIT状态，B在收到报文后进入CLOSED状态。A在发送完报文等待了2MSL时间后进入CLOSED状态。</p><p class="note note-primary">  <b>为什么 TIME_WAIT 状态要等待 2MSL 之后才关闭连接</b></p><p>2MSL表示两个MSL的时长，MSL全称为Maximum Segment Life，表示TCP Segment 生存时间的限制。</p><p>若服务器在 1 MSL 内没有收到客户端发出的 ACK 确认报文，再次向客户端发出 FIN 报文。如果客户端在 2 MSL 内收到了服务器再次发来的 FIN 报文，说明服务器并没有收到客户端发出的 ACK 确认报文。客户端将再次向服务器发出 ACK 确认报文，并重新开始 2 MSL 的计时。</p><p>若服务端将重发 FIN 报文时客户端并没有维持 TIME-WAIT 状态而直接关闭，当收到服务端重新发送的 FIN 包时，客户端就会用 RST 包来响应服务端，这将会使得对方认为是有错误发生，然而其实只是正常的关闭连接过程，并没有出现异常情况。</p><p>此外，如果客户端在收到服务端的 FIN 报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现。</p><p class="note note-primary">  <b>TIME_WAIT 状态导致的问题</b></p><p>考虑高并发短连接的业务场景，在高并发短连接的 TCP 服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的连接失败。</p><p>服务器可以设置 SO_REUSEADDR 套接字选项来通知内核，如果端口被占用，但 TCP 连接位于 TIME_WAIT 状态时可以重用端口。如果服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时 SO_REUSEADDR 选项就可以避免 TIME-WAIT 状态。</p><p>也可以采用长连接的方式减少 TCP 的连接与断开，在长连接的业务中往往不需要考虑 TIME-WAIT 状态，但其实在长连接的业务中并发量一般不会太高。</p><h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.jiar.me/2017/08/11/TCP三次握手简介/">Jiar.TCP三次握手简介</a></p><p><a href="https://blog.jiar.me/2017/08/24/TCP四次挥手简介/">Jiar.TCP四次挥手简介</a></p><p><a href="https://blog.csdn.net/qzcsu/article/details/72861891">小书go.TCP的三次握手与四次挥手</a></p><p><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ek40dd/">Leetcode.计算机网络面试-传输层</a></p><p><a href="https://zhuanlan.zhihu.com/p/53374516">Stefno.三次握手，四次挥手</a></p><h1 id="网络安全篇"><a href="#网络安全篇" class="headerlink" title="网络安全篇"></a>网络安全篇</h1><h2 id="安全攻击分类"><a href="#安全攻击分类" class="headerlink" title="安全攻击分类"></a>安全攻击分类</h2><p><span class="label label-primary">被动攻击</span>：攻击者窃听监听数据传输，从而获取到传输的数据信息。主要有：消息内容泄露攻击和流量分析攻击。由于并没有修改数据，这种攻击是很难被检测到的。</p><p><span class="label label-primary">主动攻击</span>：攻击者修改传输的数据流或者故意添加错误的数据流，如假冒用户身份从而得到一些权限，进行权限攻击，除此之外，还有重放、改写和拒绝服务等。</p><h2 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h2><p><strong>ARP 是一种非常不安全的协议</strong>，局域网上的任何一台主机如果接收到一个 ARP 应答报文，并不会去检测这个报文的真实性，而是直接记入自己的 ARP 缓存表中，当 ARP 表中的某一记录长时间不适使用，就会被删除。ARP 攻击就是利用了这一点，攻击者疯狂发送 ARP 报文，源 IP 地址为被攻击者的 IP 地址，而源 MAC 地址为攻击者的 MAC 地址。通过不断发送这些伪造的 ARP 报文，网络内部的主机和网关的 ARP 表中被攻击者的 IP 地址对应攻击者的 MAC 地址。所有发送给被攻击者的信息都会发送到攻击者的主机上，从而产生 ARP 欺骗。ARP 欺骗分为以下几种：</p><ul><li><strong>洪泛攻击</strong></li></ul><p>攻击者恶意向局域网中的网关、路由器和交换机等发送大量 ARP 报文，设备 CPU 忙于处理 ARP 协议，难以响应正常的服务请求。表现通常为：网络中断或者网速很慢。</p><ul><li><strong>欺骗主机</strong></li></ul><p>也叫仿冒网关攻击，攻击者通过 ARP 欺骗使得被攻击者 ARP 表中网关对应的 MAC 地址为攻击者的 MAC。这样一来被攻击者要通过网关发送出去的数据流就会发往攻击者这里，造成用户数据外泄。</p><ul><li><strong>欺骗网关</strong></li></ul><p>和欺骗主机的攻击方式类似，不过欺骗对象是局域网的网关。当局域网中的主机向网关发送数据时，网关会把数据发送给攻击者，该攻击方式同样会造成用户数据外泄。</p><ul><li><strong>中间人攻击</strong></li></ul><p>攻击者同时欺骗网关和主机，局域网的网关和主机发送的数据最后都会到达攻击者这边。这样，网关和用户的数据就会泄露。</p><ul><li><strong>IP 地址冲突</strong></li></ul><p>攻击者对局域网中的主机进行扫描，然后根据物理主机的 MAC 地址进行攻击，导致局域网内的主机产生 IP 冲突，使得用户的网络无法正常使用。</p><h2 id="DDoS攻击"><a href="#DDoS攻击" class="headerlink" title="DDoS攻击"></a>DDoS攻击</h2><p>DDoS 全称 Distributed Denial of Service，分布式拒绝服务。一般来说是指攻击者利用不同位置上的“肉鸡”对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。和单一的 DoS 攻击相比，DDoS 是借助数百台或者数千台已被入侵并添加了攻击进程的主机组成“僵尸网络”，一起发起网络攻击。</p><p>DDOS 不是一种攻击，而是一大类攻击的总称。它有几十种类型，新的攻击方法还在不断发明出来。</p><p class="note note-primary">  <b>SYN Flood</b></p><p>这是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，从而使得被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。</p><p>建立TCP连接，需要三次握手：客户端发送SYN报文，服务端收到请求并返回报文表示接受，客户端也返回确认，完成连接。如果客户端向服务器发送报文后死机或掉线，服务器在发出应答报文后就无法收到客户端的确认报文，这时服务器端一般会重试并等待一段时间后再丢弃这个未完成的连接。Linux下默认会进行5次重发 SYN-ACK 包，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为<code>指数退避</code>，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要63s, TCP 才会把断开这个连接。由于 SYN 超时需要63秒，就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server，服务器端为了维护数以万计的半连接而消耗非常多的资源，最后Server的SYN队列被耗尽或可用端口被全部占用等。</p><p><strong>防范SYN Flood的方法</strong></p><ul><li><strong>Syn Cache技术</strong></li></ul><p>这种技术是在收到SYN数据报文时不急于去分配TCB，而是先回应一个SYN ACK报文，并在一个专用HASH表（Cache）中保存这种半开连接信息，直到收到正确的回应ACK报文再分配TCB。在FreeBSD系统中这种 Cache每个半开连接只需使用160字节，远小于TCB所需的736个字节。在发送的SYN ACK中需要使用一个己方的Sequence Number，这个数字不能被对方猜到，否则对于某些稍微智能一点的Syn Flood攻击软件来说，它们在发送Syn报文后会发送一个ACK报文，如果己方的Sequence Number被对方猜测到，则会被其建立起真正的连接。因此一般采用一些加密算法生成难于预测的Sequence Number。</p><ul><li><strong>Syn Cookie技术</strong></li></ul><p>Syn Cache虽然不分配TCB，但是为了判断后续对方发来的ACK报文中的Sequence Number的正确性，还是需要使用一些空间去保存己方生成的Sequence Number等信息，也造成了一些资源的浪费。</p><p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。</p><ul><li><strong>Syn Proxy防火墙</strong></li></ul><p>Syn Cache技术和Syn Cookie技术总的来说是一种主机保护技术，需要系统的TCP/IP协议栈的支持，而目前并非所有的操作系统支持这些技术。因此很多防火墙中都提供一种SYN代理的功能，其主要原理是对试图穿越的SYN请求进行验证后才放行：</p><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记7.gif?raw=true" alt=""></p><p>防火墙在确认了连接的有效性后，才向内部的服务器（Listener）发起SYN请求，在右图中，所有的无效连接均无法到达内部的服务器。而防火墙采用的验证连接有效性的方法则可以是Syn Cookie等其他技术。</p> <p class="note note-primary">  <b>CC 攻击</b></p><p>CC攻击是目前应用层攻击的主要手段之一，攻击者模拟多个正常用户送来大量正常的请求，超出服务器的最大承受量，导致宕机。</p><p><strong>防范 CC 攻击的方法</strong></p><ul><li><strong>拦截HTTP请求</strong></li></ul><p>如果恶意请求有特征，对付起来很简单：直接拦截它就行了。</p><p>HTTP 请求的特征一般有两种：IP 地址和 User Agent 字段。比如，恶意请求都是从某个 IP 段发出的，那么把这个 IP 段封掉就行了。或者，它们的 User Agent 字段有特征（包含某个特定的词语），那就把带有这个词语的请求拦截。</p><ul><li><strong>带宽扩容</strong></li></ul><p>HTTP 拦截有一个前提，就是请求必须有特征。但是，真正的 DDOS 攻击是没有特征的，它的请求看上去跟正常请求一样，而且来自不同的 IP 地址，所以没法拦截。</p><p>对于网站来说，如果可以在短时间内急剧扩容，提供几倍或几十倍的带宽，就可以顶住大流量的请求。这就是为什么云服务商可以提供防护产品，因为他们有大量冗余带宽，可以用来消化 DDoS 攻击。当有大量请求时，DNS 将访问量均匀分配到这四台镜像服务器。</p><ul><li><strong>CDN</strong></li></ul><p>CDN 指的是网站的静态内容分发到多个服务器，用户就近访问，提高速度。因此，CDN 也是带宽扩容的一种方法，可以用来防御 DDOS 攻击。</p><p>网站内容存放在源服务器，CDN 上面是内容的缓存。用户只允许访问 CDN，如果内容不在 CDN 上，CDN 再向源服务器发出请求。这样的话，只要 CDN 够大，就可以抵御很大的攻击。不过，这种方法有一个前提，网站的大部分内容必须可以静态缓存。对于动态内容为主的网站（比如论坛），就要想别的办法，尽量减少用户对动态数据的请求。</p><p>上一节提到的镜像服务器，本质就是自己搭建一个微型 CDN。各大云服务商提供的<a href="https://baike.baidu.com/item/高防服务器">高防 IP</a>，背后也是这样做的：网站域名指向高防 IP，它提供一个缓冲层，清洗流量，并对源服务器的内容进行缓存。</p><p>这里有一个关键点，使用 CDN，千万不要泄露源服务器的 IP 地址，否则攻击者可以绕过 CDN 直接攻击源服务器，前面的努力都白费。</p><h2 id="参考资料-3"><a href="#参考资料-3" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.ruanyifeng.com/blog/2018/06/ddos.html">阮一峰.DDoS的防范教程</a></p><p><a href="https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ekb9m1/">Leetcode.计算机网络面试-网络安全</a></p><p><a href="https://www.zhihu.com/question/22259175/answer/378530276">知道创宇.什么是DDoS攻击</a></p><p><a href="https://blog.csdn.net/bill_lee_sh_cn/article/details/6065704">一头老毅.SYN Flood攻击及防御方法</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经</title>
    <link href="/2021/08/06/%E9%9D%A2%E7%BB%8F/"/>
    <url>/2021/08/06/%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="C-C-static关键字作用"><a href="#C-C-static关键字作用" class="headerlink" title="C/C++ static关键字作用"></a>C/C++ static关键字作用</h1><ol><li><p>隐藏：当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p></li><li><p>全局生命周期：存储在静态数据区的变量会在程序刚开始运行时就完成唯一的一次初始化。 共有两种变量存储在静态存储区：全局变量和static变量，与全局变量相比，static可以控制变量的可见范围。</p></li><li><p>变量默认初始化为0：在静态数据区，内存中所有的字节默认值都是0x00，所以全局变量也具备这一属性。</p></li><li><p>C++中的类成员声明static</p><ul><li>static修饰的变量或函数是属于类的，所有对象只有一份拷贝。 因此，不能将静态函数设为虚函数。  </li><li>静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）  </li></ul></li></ol><h1 id="vector是如何扩容的"><a href="#vector是如何扩容的" class="headerlink" title="vector是如何扩容的"></a>vector是如何扩容的</h1><p>往vector中添加元素时，如果空间不够将会导致扩容。vector有两个属性：size和capacity。size表示已经使用的数据容量，capacity表示数组的实际容量，包含已使用的和未使用的。</p><p>vector扩容规则：</p><ol><li>当数组大小不够容纳新增元素时，开辟更大的内存空间，把旧空间上的数据复制过来，然后在新空间中继续增加。</li><li>新的更大的内存空间，一般是当前空间的1.5倍或者2倍，这个1.5或者2被称为扩容因子，不同系统实现扩容因子也不同。</li></ol><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><p>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在统一作用域中。</p><p>覆盖：子类继承父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写。</p><p>重写：</p><p>（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。<br>（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</p><h1 id="2-5亿个数求不重复数"><a href="#2-5亿个数求不重复数" class="headerlink" title="2.5亿个数求不重复数"></a>2.5亿个数求不重复数</h1><p>有2.5亿个整数(这2.5亿个整数存储在一个数组里面，至于数组是放在外存还是内存，没有进一步具体说明)；<br>要求找出这2.5亿个数字里面， 不重复的数字的个数 ； 另外，可用的内存限定为600M； </p><p>用一个bit表示一个数是否存在，32bit中无符号整数有4G个，共需4G bits，每个字节8 bits，需要4G/8 = 512M字节；申请512M内存，作为一个数是否存在的标记flag，全清0；申请另外一组bit作为计数器count，全清0；</p><h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><p><code>volatile</code>直译为易失性的，意在声明某变量有可能被编译器未知的因素更改，如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，<strong>编译器对访问该变量的代码就不再进行优化</strong>。例如：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitForSemaphore</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">uint16_t</span>* semPtr = WELL_KNOWN_SEM_ADDR;<span class="hljs-comment">/*well known address to my semaphore*/</span>   <span class="hljs-keyword">while</span> ((*semPtr) != IS_OK_FOR_ME_TO_PROCEED);&#125;</code></pre></div><p>如果未进行易失性声明，优化编译器会把变量从内存装入CPU寄存器中， 即使其他线程对内存中的变量进行修改，当前线程只使用寄存器中的值，<code>while</code>循环将是一个死循环；加修饰字之后，编译器每次操作该变量时会从内存中真正取出。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> i=<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> a = i;<span class="hljs-keyword">int</span> b = i;</code></pre></div><p><code>volatile</code>指出<code>i</code>是随时可能发生变化的，每次使用它的时候必须从<code>i</code>的地址中读取，因而编译器生成的汇编代码会重新从<code>i</code>的地址读取数据放在<code>b</code>中。而优化做法是，由于编译器发现两次读数据的代码之间的代码没有对<code>i</code>进行过操作，它会自动把上次读的数据放在 <code>b</code>中。而不是重新从<code>i</code>里面读。</p><p><strong>参考</strong></p><p><a href="https://stackoverflow.com/a/72576/16657286">https://stackoverflow.com/a/72576/16657286</a></p><p><a href="https://zhuanlan.zhihu.com/p/62060524">https://zhuanlan.zhihu.com/p/62060524</a></p><h1 id="常驻内存和共享内存"><a href="#常驻内存和共享内存" class="headerlink" title="常驻内存和共享内存"></a>常驻内存和共享内存</h1><ul><li>常驻内存：进程间切换时，操作系统会将数据从内存复制到磁盘上来释放一部分内存。然而，当一部分内存指定为<em>常驻</em>时，它不会与磁盘交换。使频繁访问的数据常驻在内存中可以减少访问该数据所需的磁盘 I/O 操作，如操作系统的中心部分和一些特殊程序，如日历和计算器。</li><li>共享内存是进程间通信中最简单的方式之一。共享内存允许两个或更多进程访问同一块内存，当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。</li></ul><h1 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h1><p>DNS （Domain Name System）的作用非常简单，就是根据域名查出IP地址。</p><p>客户端在上网的时候，需要设置：本机的IP地址、子网掩码、网关的IP地址、DNS服务器的IP地址。我们就是通过DNS服务器查得域名对应的IP地址。DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。</p><p>DNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询。</p><p><strong>域名的层级</strong></p><p>举例来说，<code>www.example.com</code>真正的域名是<code>www.example.com.root</code>，简写为<code>www.example.com.</code>。因为，根域名<code>.root</code>对于所有域名都是一样的，所以平时是省略的。</p><p>根域名的下一级，叫做”顶级域名”（top-level domain，缩写为TLD），比如<code>.com</code>、<code>.net</code>；再下一级叫做”次级域名”（second-level domain，缩写为SLD），比如<code>www.example.com</code>里面的<code>.example</code>，这一级域名是用户可以注册的；再下一级是主机名（host），比如<code>www.example.com</code>里面的<code>www</code>，又称为”三级域名”，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。</p><p>总结一下，域名的层级结构如下。</p><div class="code-wrapper"><pre><code class="hljs no">主机名.次级域名.顶级域名.根域名# 即host.sld.tld.root</code></pre></div><p><strong>DNS记录</strong></p><p>域名与IP之间的对应关系，称为”记录”。根据使用场景，”记录”可以分成不同的类型。</p><div class="code-wrapper"><pre><code class="hljs dns">（<span class="hljs-number">1</span>） <span class="hljs-keyword">A</span>：地址记录（Address），返回域名指向的IP地址。（<span class="hljs-number">2</span>） <span class="hljs-keyword">NS</span>：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。（<span class="hljs-number">3</span>）<span class="hljs-keyword">CNAME</span>：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转。</code></pre></div><p><strong>分级查询</strong></p><p>“分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址。每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。过程大致如下。</p><div class="code-wrapper"><pre><code class="hljs no">1. 从&quot;根域名服务器&quot;查到&quot;顶级域名服务器&quot;的NS记录和A记录（IP地址）2. 从&quot;顶级域名服务器&quot;查到&quot;次级域名服务器&quot;的NS记录和A记录（IP地址）3. 从&quot;次级域名服务器&quot;查出&quot;主机名&quot;的IP地址</code></pre></div><p>上面，”根域名服务器”的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面。</p><p><strong>参考</strong></p><p><a href="https://www.ruanyifeng.com/blog/2016/06/dns.html">https://www.ruanyifeng.com/blog/2016/06/dns.html</a></p><h1 id="进程的内存分布"><a href="#进程的内存分布" class="headerlink" title="进程的内存分布"></a>进程的内存分布</h1><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/面经1.png?raw=true" alt=""></p><p>从低地址到高地址，分别包括：</p><ol><li>文本段，也叫代码段，是对象文件或内存中程序的一部分，其中包含可执行指令。通常代码段是共享的，对于经常执行的程序，只有一个副本需要存储在内存中，代码段是只读的，以防止程序以外修改指令。</li><li>初始化的数据段，是程序的虚拟地址空间的一部分，它包含有程序员初始化的全局变量和静态变量，可以进一步划分为只读区域和读写区域。例如，C中的char=“hello world”的全局字符串，以及main(例如全局)之外的int debug=1这样的C语句。</li><li>未初始化的数据段，通常称为bss段，这个段的数据在程序开始之前有内核初始化为0，包含所有初始化为0和没有显示初始化的全局变量和静态变量，</li><li>堆，堆是动态内存分配通常发生的部分。堆是由程序员自己分配的（malloc kmalloc等）。堆区域由所有共享库和进程中动态加载的模块共享。</li><li>栈，存放临时变量，以及每次调用函数时调用栈。每当调用一个函数时，返回到的地址和关于调用者环境的某些信息的地址，比如一些机器寄存器，就会被保存在栈中。然后，新调用的函数在栈上分配空间，用于自动和临时变量。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac下使用GitHub+Hexo+Fluid搭建个人博客</title>
    <link href="/2021/08/03/blog-init/"/>
    <url>/2021/08/03/blog-init/</url>
    
    <content type="html"><![CDATA[<h1 id="安装：Git、node-js、-hexo"><a href="#安装：Git、node-js、-hexo" class="headerlink" title="安装：Git、node.js、 hexo"></a>安装：Git、node.js、 hexo</h1><ol><li><p>安装Homebrew</p></li><li><p>安装node.js</p><div class="code-wrapper"><pre><code class="hljs crmsh">brew install <span class="hljs-keyword">node</span><span class="hljs-title"></span></code></pre></div></li><li><p>安装git</p><ul><li><p>一种方法是安装Xcode</p></li><li><p>另一种方法是</p><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>git</code></pre></div></li></ul></li><li><p>使用 npm 安装 hexo</p><div class="code-wrapper"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span></code></pre></div></li></ol><h1 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h1><ol><li><p>在某位置新建blogs文件夹，如<code>～/Documents/blogs</code>，并<code>cd</code>入该文件夹</p></li><li><p>博客初始化，这一步会在<code>blogs</code>中生成一些配置文件</p><div class="code-wrapper"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span></code></pre></div></li><li><p>进行本地预览</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span></code></pre></div></li><li><p>在<code>http://localhost:4000</code>进行预览，看到HEXO的<code>hello world</code>界面即为成功</p></li></ol><h1 id="添加SSH-Key到github"><a href="#添加SSH-Key到github" class="headerlink" title="添加SSH Key到github"></a>添加SSH Key到github</h1><ul><li><code>Enter file in which to save the key</code>时直接按回车，即在默认位置生成ssh文件，即<code>/Users/xxx/.ssh/id_rsa.pub</code></li><li><code>Enter passphrase</code>时直接回车即不需要密码，如设置密码，该密码为push时需要的密码，与github账户密码等无关</li></ul><div class="code-wrapper"><pre><code class="hljs gradle">% git config --global user.name <span class="hljs-string">&quot;github账户名，大小写敏感&quot;</span>                   % git config --global user.email <span class="hljs-string">&quot;github账户邮箱&quot;</span>% ssh-keygen -t rsa -C <span class="hljs-string">&quot;github账户邮箱&quot;</span>Generating <span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span> rsa key pair.Enter <span class="hljs-keyword">file</span> in which to save the key (<span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/.ssh/i</span>d_rsa): Created directory <span class="hljs-string">&#x27;/Users/lihan/.ssh&#x27;</span>.Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase): Enter same passphrase again: Your identification has been saved in <span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/.ssh/i</span>d_rsa.Your <span class="hljs-keyword">public</span> key has been saved in <span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub.</code></pre></div><p>生成文件之后，复制<code>id_rsa.pub</code>中的内容，这就是需要的key；登陆github -&gt; setting -&gt; SSH and GPG keys -&gt; New SSH key，将key复制粘贴，Title可以取名为设备名</p><h1 id="本地博客关联到Github主页"><a href="#本地博客关联到Github主页" class="headerlink" title="本地博客关联到Github主页"></a>本地博客关联到Github主页</h1><ol><li><p>登录Github并且创建一个名字为 <code>username.github.io</code> 的仓库，如<code>HerloConnell.github.io</code>，选择<code>Public</code></p></li><li><p>修改<code>blogs/_config.yml</code>的<code>deploy</code>，注意这里使用的是分支master</p><p><strong>在8.13号以后git需要使用令牌，repo设置稍有改动，具体见错误2</strong></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/HerloConnell/HerloConnell.github.io.git</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre></div></li><li><p>将博客push到GitHub</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><span class="hljs-attribute">hexo d</span></code></pre></div></li><li><p>在该仓库的<code>settings</code>中选择<code>GitHub Pages</code>,点击<code>heck it out here!</code>，显示</p><div class="code-wrapper"><pre><code class="hljs delphi">Your site <span class="hljs-keyword">is</span> <span class="hljs-keyword">published</span> at https:<span class="hljs-comment">//herloconnell.github.io/</span></code></pre></div><p>在<code>Source</code>处选择<code>Branch:master</code></p></li><li><p>再次执行下面的代码，此时应该可以在<code>https://herloconnell.github.io/</code>看到Hexo界面</p><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><span class="hljs-attribute">hexo d</span></code></pre></div></li></ol><h1 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h1><div class="code-wrapper"><pre><code class="hljs axapta">hexo n <span class="hljs-string">&quot;博客名称&quot;</span>  =&gt; hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;博客名称&quot;</span>   <span class="hljs-meta">#这两个都是创建新文章，前者是简写模式</span>hexo p  =&gt; hexo publishhexo g  =&gt; hexo generate  <span class="hljs-meta">#生成</span>hexo s  =&gt; hexo <span class="hljs-keyword">server</span>  <span class="hljs-meta">#启动服务预览</span>hexo d  =&gt; hexo deploy  <span class="hljs-meta">#部署  </span>hexo <span class="hljs-keyword">server</span>   <span class="hljs-meta">#Hexo 会监视文件变动并自动更新，无须重启服务器。</span>hexo <span class="hljs-keyword">server</span> -s   <span class="hljs-meta">#静态模式</span>hexo <span class="hljs-keyword">server</span> -p <span class="hljs-number">5000</span>   <span class="hljs-meta">#更改端口</span>hexo <span class="hljs-keyword">server</span> -i <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>   <span class="hljs-meta">#自定义IP</span>hexo clean   <span class="hljs-meta">#清除缓存，网页正常情况下可以忽略此条命令</span>hexo g   <span class="hljs-meta">#生成静态网页</span>hexo d   <span class="hljs-meta">#开始部署</span></code></pre></div><h1 id="Fluid主题"><a href="#Fluid主题" class="headerlink" title="Fluid主题"></a>Fluid主题</h1><p><a href="https://hexo.io/themes/">hexo主题网站</a>，<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a></p><ol><li><p>在<code>/blogs/themes</code>中</p><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/fluid-dev/hexo-theme-fluid.git</code></pre></div></li><li><p>将<code>hexo-theme-fluid</code>文件夹更名为<code>fluid</code>，并修改hexo的<code>_config.yml</code></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span></code></pre></div></li><li><p>参考<code>Fluid</code>主题配置进行配置，如配置<code>Latex</code>支持等（注：<code>Latex</code>需要在文章 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a>里指定 <code>math: true</code> 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度）</p></li></ol><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p><strong>错误一：443</strong></p><div class="code-wrapper"><pre><code class="hljs bash">fatal unable to access https://github.com LibreSSL SSL_connect SSL_ERROR_SYSCALL <span class="hljs-keyword">in</span> connection to github.com 443</code></pre></div><p>科学上网的换个节点或者多提交几次即可</p><p><strong>错误二：403</strong></p><div class="code-wrapper"><pre><code class="hljs bash">remote: Support <span class="hljs-keyword">for</span> password authentication was removed on August 13, 2021. Please use a personal access token instead.remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ <span class="hljs-keyword">for</span> more information.fatal: unable to access <span class="hljs-string">&#x27;https://github.com/HerloConnell/HerloConnell.github.io.git/&#x27;</span>: The requested URL returned error: 403</code></pre></div><p>2021年8月13后 GitHub 不能再用密码pull/push 需要使用令牌。</p><ul><li><p>进入 Github —&gt; Settings —&gt; Developer settings —&gt; Personal access tokens获得一个token，这里作用域我点的全选。</p></li><li><p>修改<code>config</code></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://&lt;Token&gt;@github.com/HerloConnell/HerloConnell.github.io.git</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂七杂八</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
