<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图解计算机网络笔记</title>
    <link href="/2021/08/07/%E5%9B%BE%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/07/%E5%9B%BE%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP-篇"><a href="#HTTP-篇" class="headerlink" title="HTTP 篇"></a>HTTP 篇</h1><h2 id="2-2-HTTP-1-1如何优化"><a href="#2-2-HTTP-1-1如何优化" class="headerlink" title="2.2 HTTP/1.1如何优化"></a>2.2 HTTP/1.1如何优化</h2><ol><li><p>减少HTTP请求次数</p><ul><li><p><strong>缓存</strong></p><p>服务器在返回资源的时候，同时返回一个预估的过期时间，客户端以URL作为key，资源作为value的形式存储在本地。在此访问同URL时，先查询本地磁盘，如果存在：若未过期，直接返回资源；否则，再次发起请求，并附带本地过期资源的摘要，若服务器发现资源未变动，直接返回不含有包体的 <strong>304 Not Modified</strong> 响应，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时。</p></li><li><p><strong>重定向服务交给代理服务器</strong></p></li><li><p><strong>合并请求</strong></p><p>如将小图片合为一张大图片，js、css等小资源合为一个文件。以一个大资源的请求替换多个小资源的请求。 但当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件，带来了额外的网络消耗。</p></li><li><p><strong>延迟发送请求</strong> </p><p>按需获取。请求网⻚的时候只获取当前用户所看到的⻚面资源，当用户向下滑动⻚面的时候，再向服务器获取接下来的资源。</p></li></ul></li><li><p>减少HTTP响应数据大小</p><ul><li><strong>无损压缩</strong></li><li><strong>有损压缩</strong></li></ul></li></ol><h2 id="2-3-HTTPS-解析"><a href="#2-3-HTTPS-解析" class="headerlink" title="2.3 HTTPS 解析"></a>2.3 HTTPS 解析</h2><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>加密算法分为以下两种：</p><ol><li><p><strong>对称加密</strong></p><ul><li>甲方选择某一种加密规则，对信息进行加密；乙方使用同一种规则，对信息进行解密；</li><li>加密和解密使用同样规则（简称”<strong>密钥</strong>“）。</li></ul><p>甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。</p></li></ol><p>后来，人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。</p><ol><li><p><strong>不对称加密</strong>：公钥加密算法</p><ul><li>乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的；甲方获取乙方的公钥，然后用它对信息加密。乙方得到加密后的信息，用私钥解密；</li><li>公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立；</li><li>所有的（公钥, 私钥）对都是不同的；</li><li><strong>用公钥可以解开私钥加密的信息，反之亦成立</strong>；</li><li>同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的；</li><li>在双钥体系中，<strong>公钥用来加密信息，私钥用来数字签名</strong>。</li></ul><p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</p></li></ol><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>不对称加密过程中，双方的通信是建立在公钥可信的基础上的：</p><ol><li>B对数据进行Hash生成<strong>摘要</strong>后，使用私钥对摘要进行加密，生成<strong>数字签名</strong>；B将数据和数字签名一同发给A；</li><li>A对数据进行相同的Hash，并对数字签名使用B的公钥解密；如果解密结果与Hash结果相同，则确认为B发出。</li></ol><p>如果一开始A拿到的公钥就是假的话，那么B后来发出的任何内容A均无法识别。问题在于A获取公钥的过程依然是明文传输的，为此提出数字证书的方法，通过可信的第三方（CA）对公钥进行签名，保证B的公钥通过可信的方式传递给A：</p><ol><li>CA使用私钥对B的公钥及相关信息如证书的颁布机构、有效期、持有者进行签名，生成数字证书；</li><li>B将数据，数字签名，数字证书一同发送给A；</li><li>CA的公钥也是需要使用证书来分发的，所以 A的电脑必须安装CA的证书，证书里包含CA的公钥。</li><li>A用CA的公钥解开数字证书，验证证书的可信性；从证书拿到B真实的公钥，验证”数字签名”是否真的是B签的。</li></ol><p><strong>为什么先进行摘要再进行签名？</strong></p><p>原数据过大，加密算法耗时。</p><h3 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h3><p>HTTP 由于是明文传输，所谓的明文，就是说客户端与服务端通信的信息都是肉眼可⻅的，随意使用一个抓包工具都可以截获通信的内容。<br>所以安全上存在以下三个⻛险</p><ul><li><strong>窃听风险</strong>：第三方可以获知通信内容；</li><li><strong>篡改风险</strong>：第三方可以修改通信内容；</li><li><strong>冒充风险</strong>：第三方可以冒充他人身份参与通信。</li></ul><p>HTTPS 在 HTTP 与 TCP 层之间加入了SSL/TLS协议，来解决上述的⻛险。</p><ul><li>所有信息都是<strong>加密传播</strong>，第三方无法窃听；</li><li>具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现；</li><li>配备<strong>身份证书</strong>，防止身份被冒充。</li></ul><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记1.png?raw=true" alt=""></p><p>SSL/TLS协议的基本思路是采用<a href="https://en.wikipedia.org/wiki/Public-key_cryptography">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p>但是，这里有两个问题。</p><ol><li><p>如何保证公钥不被篡改？</p><p>将公钥放在<a href="https://en.wikipedia.org/wiki/Digital_certificate">数字证书（CA）</a>中。只要证书是可信的，公钥就是可信的。</p></li><li><p>公钥加密计算量太大，如何减少耗用的时间？</p><p>采用<strong>混合加密</strong>。每一次对话，客户端和服务器端都生成一个”<strong>对话密钥</strong>“，用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p></li></ol><p>因此，SSL/TLS协议的基本过程是这样的：</p><ul><li><p>客户端向服务器端索要并验证公钥；</p></li><li><p>双方协商生成”对话密钥”；</p></li><li><p>双方采用”对话密钥”进行加密通信；</p></li></ul><p>上面过程的前两步，又称为”握手阶段”。</p><h3 id="基于RSA加密的SSL-TSL握手"><a href="#基于RSA加密的SSL-TSL握手" class="headerlink" title="基于RSA加密的SSL/TSL握手"></a>基于RSA加密的SSL/TSL握手</h3><p>也是基础的SSL/TSL握手过程</p><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记2.png?raw=true" alt=""></p><p><strong>1. 客户端发出请求（ClientHello）</strong></p><p>客户端向服务器发出加密通信的请求，称为ClientHello请求，客户端主要向服务器提供以下信息：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">（<span class="hljs-number">1</span>） 支持的协议版本，比如TLS <span class="hljs-number">1.0</span>版。<br>（<span class="hljs-number">2</span>） 一个客户端生成的随机数<span class="hljs-built_in">Client</span> random，稍后用于生成<span class="hljs-string">&quot;对话密钥&quot;</span>。<br>（<span class="hljs-number">3</span>） 支持的加密方法，比如RSA公钥加密。<br>（<span class="hljs-number">4</span>） 支持的压缩方法。<br></code></pre></td></tr></table></figure><p><strong>2. 服务器回应（SeverHello）</strong></p><p>服务器的回应包含以下内容：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">（<span class="hljs-number">1</span>） 确认使用的加密通信协议版本，比如TLS <span class="hljs-number">1.0</span>版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。<br>（<span class="hljs-number">2</span>） 一个服务器生成的随机数<span class="hljs-built_in">Server</span> random，稍后用于生成<span class="hljs-string">&quot;对话密钥&quot;</span>。<br>（<span class="hljs-number">3</span>） 确认使用的加密方法，比如RSA公钥加密。<br>（<span class="hljs-number">4</span>） 服务器证书。<br></code></pre></td></tr></table></figure><p><strong>3. 客户端回应</strong></p><p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p><p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。<br><br>（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br><br>（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的<span class="hljs-built_in">hash</span>值，用来供服务器校验。<br></code></pre></td></tr></table></figure><p>此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p><p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p><p>值得注意的是，该过程之前的阶段均为明文传输；而pre-master key使用服务器公钥加密，之后客户端与服务器端均生成会话密钥，数据传输均为加密传输。</p><p><strong>4. 服务器的最后回应</strong></p><p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br><br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的<span class="hljs-built_in">hash</span>值，用来供客户端校验。<br></code></pre></td></tr></table></figure><p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p><p>使用 RSA密钥协商算法的最大问题是不支持前向保密。整个握手阶段都不加密（也没法加密），都是明文的。如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。所以一旦服务端的私钥泄漏 了，过去被第三方截获的所有 TLS 通讯密文都会被破解。</p><h3 id="基于ECDHE加密的SSL-TSL握手"><a href="#基于ECDHE加密的SSL-TSL握手" class="headerlink" title="基于ECDHE加密的SSL/TSL握手"></a>基于ECDHE加密的SSL/TSL握手</h3><p>参考资料</p><p><a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">阮一峰.RSA算法原理（一）</a></p><p><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">阮一峰.SSL/TLS协议运行机制的概述</a></p><p><a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">小林coding.图解 HTTP 常见的面试题</a></p><p><a href="https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">阮一峰.数字签名是什么</a></p><p><a href="http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html">阮一峰.密码学笔记</a></p><p><a href="https://segmentfault.com/a/1190000024523772">编程指北.加密、数字签名和数字证书</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面经</title>
    <link href="/2021/08/06/%E9%9D%A2%E7%BB%8F/"/>
    <url>/2021/08/06/%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="C-C-static关键字作用"><a href="#C-C-static关键字作用" class="headerlink" title="C/C++static关键字作用"></a>C/C++static关键字作用</h1><ol><li><p>隐藏：当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p></li><li><p>全局生命周期：存储在静态数据区的变量会在程序刚开始运行时就完成唯一的一次初始化。 共有两种变量存储在静态存储区：全局变量和static变量，与全局变量相比，static可以控制变量的可见范围。</p></li><li><p>变量默认初始化为0：在静态数据区，内存中所有的字节默认值都是0x00，所以全局变量也具备这一属性。</p></li><li><p>C++中的类成员声明static</p><ul><li>static修饰的变量或函数是属于类的，所有对象只有一份拷贝。 因此，不能将静态函数设为虚函数。  </li><li>静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）  </li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac下使用GitHub+Hexo+Fluid搭建个人博客</title>
    <link href="/2021/08/03/blog-init/"/>
    <url>/2021/08/03/blog-init/</url>
    
    <content type="html"><![CDATA[<h1 id="安装：Git、node-js、-hexo"><a href="#安装：Git、node-js、-hexo" class="headerlink" title="安装：Git、node.js、 hexo"></a>安装：Git、node.js、 hexo</h1><ol><li><p>安装Homebrew</p></li><li><p>安装node.js</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">brew install <span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure></li><li><p>安装git</p><ul><li><p>一种方法是安装Xcode</p></li><li><p>另一种方法是</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>git<br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用 npm 安装 hexo</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h1><ol><li><p>在某位置新建blogs文件夹，如<code>～/Documents/blogs</code>，并<code>cd</code>入该文件夹</p></li><li><p>博客初始化，这一步会在<code>blogs</code>中生成一些配置文件</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure></li><li><p>进行本地预览</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure></li><li><p>在<code>http://localhost:4000</code>进行预览，看到HEXO的<code>hello world</code>界面即为成功</p></li></ol><h1 id="添加SSH-Key到github"><a href="#添加SSH-Key到github" class="headerlink" title="添加SSH Key到github"></a>添加SSH Key到github</h1><ul><li><code>Enter file in which to save the key</code>时直接按回车，即在默认位置生成ssh文件，即<code>/Users/xxx/.ssh/id_rsa.pub</code></li><li><code>Enter passphrase</code>时直接回车即不需要密码，如设置密码，该密码为push时需要的密码，与github账户密码等无关</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle">% git config --global user.name <span class="hljs-string">&quot;github账户名，大小写敏感&quot;</span>                   <br>% git config --global user.email <span class="hljs-string">&quot;github账户邮箱&quot;</span><br>% ssh-keygen -t rsa -C <span class="hljs-string">&quot;github账户邮箱&quot;</span><br>Generating <span class="hljs-keyword">public</span>/<span class="hljs-keyword">private</span> rsa key pair.<br>Enter <span class="hljs-keyword">file</span> in which to save the key (<span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/.ssh/i</span>d_rsa): <br>Created directory <span class="hljs-string">&#x27;/Users/lihan/.ssh&#x27;</span>.<br>Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase): <br>Enter same passphrase again: <br>Your identification has been saved in <span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/.ssh/i</span>d_rsa.<br>Your <span class="hljs-keyword">public</span> key has been saved in <span class="hljs-regexp">/Users/</span>xxx<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub.<br><br></code></pre></td></tr></table></figure><p>生成文件之后，复制<code>id_rsa.pub</code>中的内容，这就是需要的key；登陆github -&gt; setting -&gt; SSH and GPG keys -&gt; New SSH key，将key复制粘贴，Title可以取名为设备名</p><h1 id="本地博客关联到Github主页"><a href="#本地博客关联到Github主页" class="headerlink" title="本地博客关联到Github主页"></a>本地博客关联到Github主页</h1><ol><li><p>登录Github并且创建一个名字为 <code>username.github.io</code> 的仓库，如<code>HerloConnell.github.io</code>，选择<code>Public</code></p></li><li><p>修改<code>blogs/_config.yml</code>的<code>deploy</code>，注意这里使用的是分支master</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/HerloConnell/HerloConnell.github.io.git</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure></li><li><p>将博客push到GitHub</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure></li><li><p>在该仓库的<code>settings</code>中选择<code>GitHub Pages</code>,点击<code>heck it out here!</code>，显示</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Your site <span class="hljs-keyword">is</span> <span class="hljs-keyword">published</span> at https:<span class="hljs-comment">//herloconnell.github.io/</span><br></code></pre></td></tr></table></figure><p>在<code>Source</code>处选择<code>Branch:master</code></p></li><li><p>再次执行下面的代码，此时应该可以在<code>https://herloconnell.github.io/</code>看到Hexo界面</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h1><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo n <span class="hljs-string">&quot;博客名称&quot;</span>  =&gt; hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;博客名称&quot;</span>   <span class="hljs-meta">#这两个都是创建新文章，前者是简写模式</span><br>hexo p  =&gt; hexo publish<br>hexo g  =&gt; hexo generate  <span class="hljs-meta">#生成</span><br>hexo s  =&gt; hexo <span class="hljs-keyword">server</span>  <span class="hljs-meta">#启动服务预览</span><br>hexo d  =&gt; hexo deploy  <span class="hljs-meta">#部署  </span><br><br>hexo <span class="hljs-keyword">server</span>   <span class="hljs-meta">#Hexo 会监视文件变动并自动更新，无须重启服务器。</span><br>hexo <span class="hljs-keyword">server</span> -s   <span class="hljs-meta">#静态模式</span><br>hexo <span class="hljs-keyword">server</span> -p <span class="hljs-number">5000</span>   <span class="hljs-meta">#更改端口</span><br>hexo <span class="hljs-keyword">server</span> -i <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>   <span class="hljs-meta">#自定义IP</span><br>hexo clean   <span class="hljs-meta">#清除缓存，网页正常情况下可以忽略此条命令</span><br>hexo g   <span class="hljs-meta">#生成静态网页</span><br>hexo d   <span class="hljs-meta">#开始部署</span><br></code></pre></td></tr></table></figure><h1 id="Fluid主题"><a href="#Fluid主题" class="headerlink" title="Fluid主题"></a>Fluid主题</h1><p><a href="https://hexo.io/themes/">hexo主题网站</a>，<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a></p><ol><li><p>在<code>/blogs/themes</code>中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/fluid-dev/</span>hexo-theme-fluid.git<br></code></pre></td></tr></table></figure></li><li><p>将<code>hexo-theme-fluid</code>文件夹更名为<code>fluid</code>，并修改hexo的<code>_config.yml</code></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid<br></code></pre></td></tr></table></figure></li><li><p>参考<code>Fluid</code>主题配置进行配置，如配置<code>Latex</code>支持等（注：<code>Latex</code>需要在文章 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter (opens new window)</a>里指定 <code>math: true</code> 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度）</p></li></ol><h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>如果git提交出错，出现</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">fatal unable <span class="hljs-keyword">to</span> access http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span> LibreSSL SSL_connect SSL_ERROR_SYSCALL in connection <span class="hljs-keyword">to</span> github.<span class="hljs-keyword">com</span> <span class="hljs-number">443</span><br></code></pre></td></tr></table></figure><p>科学上网的换个节点或者多提交几次即可</p>]]></content>
    
    
    <categories>
      
      <category>杂七杂八</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
