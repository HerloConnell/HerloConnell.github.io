

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#fdfdfd">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>图解计算机网络笔记 - Herlo&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/mycss.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":2},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 50vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Herlo's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                
                Category
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                
                Links
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg.svg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="图解计算机网络笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-07 09:41" pubdate>
        2021年8月7日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      91
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">图解计算机网络笔记</h1>
            
            <div class="markdown-body">
              <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文章原意是对《图解计算机网络》一书的笔记。但在阅读本书过程中，参考了网络上大量资料（每章参考资料在最后给出），已经不单单是“笔记”了。由于博客是基于我自己的知识基础，为了参加面试对网络资料进行整理得到的，可能不适用于希望对计算机网络有一个完整、大概认识的同学。</p>
<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>通过光缆、电缆、双绞线、无线电波等方式将电脑连接起来，将数据包转化为0和1的电信号进行传输，主要规定网络的一些电气特性。</p>
<h2 id="链接层"><a href="#链接层" class="headerlink" title="链接层"></a>链接层</h2><p>链接层规定了0和1的分组方式，即如何解读获得的01串。</p>
<p><strong>以太网协议</strong></p>
<p>以太网协议规定，一组电信号构成一个数据包：“帧”，每一帧包括标头（Head）和数据（Data）。</p>
<p>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p>
<p>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p>
<p><strong>MAC地址</strong></p>
<p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，叫做MAC地址。</p>
<p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示，如<code>00-B0-D0-86-BB-F7</code>，前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p>
<p><strong>广播</strong></p>
<p>以太网数据包必须知道接收方的MAC地址，然后才能发送，需要用到ARP协议，这个留到后面介绍。</p>
<p>有了MAC地址后，为了把数据包准确送到接收方，以太网采用了一种很”原始”的方式，它向本网络内所有计算机发送数据包，每台计算机自己判断是否为接收方。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p><strong>在网络间传输</strong></p>
<p>互联网是无数子网络共同组成的一个巨型网络，以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p>
<p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。”路由”，就是指如何向不同的子网络分发数据包。遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p>
<p>这就导致了”网络层”的诞生。它引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</p>
<p>“网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p>
<p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p>
<p><strong>IP协议</strong></p>
<p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p>
<p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成，习惯上，我们用分成四段的十进制数表示IP地址，从<code>0.0.0.0</code>一直到<code>255.255.255.255</code>。</p>
<p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。</p>
<p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。</p>
<p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址<code>172.16.254.1</code>，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是<code>255.255.255.0</code>。</p>
<p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算，如果结果相同的话，就表明它们在同一个子网络中。</p>
<p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p>
<p><strong>IP数据包</strong></p>
<p>IP数据包在传输过程中会被放到以太网数据包的“数据”部分，分为”标头”和”数据”两个部分。</p>
<p>“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。</p>
<p>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此理论上，一个IP数据包的”数据”部分最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>
<p><strong>ARP协议</strong></p>
<p>在发送方发送数据时，因为IP数据包是放在以太网数据包里发送的，所以我们必须知道对方的MAC地址和对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p>
<p>所以，我们需要一种机制，能够从IP地址得到MAC地址，这里可以分成两种情况。</p>
<p>第一种情况，两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p>
<p>第二种情况，两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是<code>FF:FF:FF:FF:FF:FF</code>，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，做出回复，向对方报告自己的MAC地址。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p><strong>端口到端口通信</strong></p>
<p>有了MAC地址和IP地址，可以在互联网上任意两台主机上建立通信。</p>
<p>问题是，同一台主机上有许多进程需要用到网络，也就是说，我们还需要一个参数，表示这个数据包到底供哪个进程使用。这个参数就叫做”端口”（port），它是每一个使用网卡的进程的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>“端口”是0到65535之间的一个整数，16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>
<p>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p>
<p><strong>UDP协议</strong></p>
<p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p>
<p>UDP数据包，也是由”标头”和”数据”两部分组成。”标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分。</p>
<p>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p>
<p><strong>TCP协议</strong></p>
<p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p>
<p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p>
<p>TCP协议并不能够确保数据不会遗失，但是可以确保数据一旦遗失，接收方可以得知这件事。它的缺点是过程复杂、实现困难、消耗较多的资源。</p>
<p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>“应用层”的作用，就是规定应用程序的数据格式。</p>
<p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p>
<p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。</p>
<p>应用软件在应用层实现，应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的。当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。</p>
<p>应用层工作在操作系统中的用户态，传输层及以下工作在内核态。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">阮一峰.互联网协议入门(一)</a></p>
<h1 id="HTTP-篇"><a href="#HTTP-篇" class="headerlink" title="HTTP 篇"></a>HTTP 篇</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>HTTP 是超文本传输协议，也就是<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p>
</li>
<li><p><strong>常见的状态码</strong></p>
<p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记3.png?raw=true" srcset="/img/loading.gif" lazyload alt=""></p>
</li>
<li><p><strong>http常⻅字段</strong></p>
<div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">客户端发送请求时：</span>
<span class="hljs-attr">Host:</span> <span class="hljs-string">www.A.com</span>	<span class="hljs-string">指定服务器域名</span>
<span class="hljs-attr">Connection:</span> <span class="hljs-string">keep-alive</span>	<span class="hljs-string">最常用于客户端要求服务器使用</span> <span class="hljs-string">TCP</span> <span class="hljs-string">持久连接，以便其他请求复用</span>
<span class="hljs-attr">Accept:</span> <span class="hljs-string">*/*</span>	<span class="hljs-string">客户端声明自己可以接受哪些数据格式，*/*表示接受任何格式</span>
<span class="hljs-attr">Accept-Encoding:</span> <span class="hljs-string">gzip,</span> <span class="hljs-string">deflate</span>	<span class="hljs-string">说明自己可以接受哪些压缩方法</span>


<span class="hljs-string">服务器响应请求时：</span>
<span class="hljs-attr">Content-Length:</span> <span class="hljs-number">1000</span>	<span class="hljs-string">表明本次回应的数据⻓度1000字节</span>
<span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/html;</span> <span class="hljs-string">charset=utf-8</span>	<span class="hljs-string">服务器表明自己发送的数据格式，发送的是网⻚，编码为UTF-8</span>
<span class="hljs-attr">Content-Encoding:</span> <span class="hljs-string">gzip</span> 	<span class="hljs-string">表示服务器返回的数据使用gzip压缩格式</span></code></pre></div>
</li>
<li><p><strong>GET与POST</strong></p>
<p>Get请求从服务器获取资源；</p>
<p>POST向 <strong>URI</strong> 指定的资源提交数据，数据就放在报文的 body 里，服务器响应代表处理结果。</p>
<p><strong>安全</strong>指请求方法不会破坏服务器上的资源， <strong>幂等</strong>指多次执行相同的操作，结果都是相同的。</p>
<p>GET方法就是安全且幂等的，POST是不安全的不幂等的。</p>
</li>
</ol>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p class="note note-primary">
  <b>HTTP/1.1特点</b>
</p>

<p><strong>简单</strong>：基本的报文格式就是 header + body ，头部信息也是 key-value 简单文本的形式；</p>
<p><strong>灵活</strong>：各类请求方法、URI/URL、状态码、头字段等都允许开发人员自定义和扩充，HTTP 工作在应用层，下层可以随意变化；</p>
<p><strong>无状态</strong>：服务器不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，对于关联性操作可以使用 Cookie技术解决；</p>
<p><strong>明文传输</strong>：在传输过程中的信息，是可方便阅读的，这种特性同时也有很大的安全隐患。</p>
<p class="note note-primary">
  <b>HTTP/1.1如何优化</b>
</p>

<ol>
<li><p>减少HTTP请求次数</p>
<p><span class="label label-primary">缓存</span></p>
<p>服务器在返回资源的时候，同时返回一个预估的过期时间，客户端以URL作为key，资源作为value的形式存储在本地。在此访问同URL时，先查询本地磁盘，如果存在：若未过期，直接返回资源；否则，再次发起请求，并附带本地过期资源的摘要，若服务器发现资源未变动，直接返回不含有包体的 <strong>304 Not Modified</strong> 响应，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时。</p>
<p><span class="label label-primary">重定向服务交给代理服务器</span></p>
<p><span class="label label-primary">合并请求</span></p>
<p>如将小图片合为一张大图片，js、css等小资源合为一个文件。以一个大资源的请求替换多个小资源的请求。 但当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件，带来了额外的网络消耗。</p>
<p><span class="label label-primary">延迟发送请求 </span></p>
<p>按需获取。请求网⻚的时候只获取当前用户所看到的⻚面资源，当用户向下滑动⻚面的时候，再向服务器获取接下来的资源。</p>
</li>
<li><p>减少HTTP响应数据大小</p>
<p><span class="label label-primary">无损压缩、有损压缩</span></p>
</li>
</ol>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><p>加密算法分为以下两种：</p>
<p><span class="label label-primary"><b>对称加密</b></span></p>
<ul>
<li>甲方选择某一种加密规则，对信息进行加密；乙方使用同一种规则，对信息进行解密；</li>
<li>加密和解密使用同样规则（简称”<strong>密钥</strong>“）。</li>
</ul>
<p>甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。</p>
<p>后来，人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。</p>
<p><span class="label label-primary"><b>不对称加密：公钥加密法</b></span></p>
<ul>
<li>乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的；甲方获取乙方的公钥，然后用它对信息加密。乙方得到加密后的信息，用私钥解密；</li>
<li>公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立；</li>
<li>所有的（公钥, 私钥）对都是不同的；</li>
<li><strong>用公钥可以解开私钥加密的信息，反之亦成立</strong>；</li>
<li>同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的；</li>
<li>在双钥体系中，<strong>公钥用来加密信息，私钥用来数字签名</strong>。</li>
</ul>
<p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</p>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p>不对称加密过程中，双方的通信是建立在公钥可信的基础上的：</p>
<ol>
<li>B对数据进行Hash生成<strong>摘要</strong>后，使用私钥对摘要进行加密，生成<strong>数字签名</strong>；B将数据和数字签名一同发给A；</li>
<li>A对数据进行相同的Hash，并对数字签名使用B的公钥解密；如果解密结果与Hash结果相同，则确认为B发出。</li>
</ol>
<p>如果一开始A拿到的公钥就是假的话，那么B后来发出的任何内容A均无法识别。问题在于A获取公钥的过程依然是明文传输的，为此提出数字证书的方法，通过可信的第三方（CA）对公钥进行签名，保证B的公钥通过可信的方式传递给A：</p>
<ol>
<li>CA使用私钥对B的公钥及相关信息如证书的颁布机构、有效期、持有者进行签名，生成数字证书；</li>
<li>B将数据，数字签名，数字证书一同发送给A；</li>
<li>CA的公钥也是需要使用证书来分发的，所以 A的电脑必须安装CA的证书，证书里包含CA的公钥。</li>
<li>A用CA的公钥解开数字证书，验证证书的可信性；从证书拿到B真实的公钥，验证”数字签名”是否真的是B签的。</li>
</ol>
<p><strong>为什么先进行摘要再进行签名？</strong></p>
<p>原数据过大，加密算法耗时。</p>
<h3 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h3><p>HTTP 由于是明文传输，所谓的明文，就是说客户端与服务端通信的信息都是肉眼可⻅的，随意使用一个抓包工具都可以截获通信的内容。<br>所以安全上存在以下三个⻛险</p>
<ul>
<li><strong>窃听风险</strong>：第三方可以获知通信内容；</li>
<li><strong>篡改风险</strong>：第三方可以修改通信内容；</li>
<li><strong>冒充风险</strong>：第三方可以冒充他人身份参与通信。</li>
</ul>
<p>HTTPS 在 HTTP 与 TCP 层之间加入了SSL/TLS协议，来解决上述的⻛险。</p>
<ul>
<li>所有信息都是<strong>加密传播</strong>，第三方无法窃听；</li>
<li>具有<strong>校验机制</strong>，一旦被篡改，通信双方会立刻发现；</li>
<li>配备<strong>身份证书</strong>，防止身份被冒充。</li>
</ul>
<p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记1.png?raw=true" srcset="/img/loading.gif" lazyload alt=""></p>
<p>SSL/TLS协议的基本思路是采用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Public-key_cryptography">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p>但是，这里有两个问题。</p>
<ol>
<li><p>如何保证公钥不被篡改？</p>
<p>将公钥放在<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Digital_certificate">数字证书（CA）</a>中。只要证书是可信的，公钥就是可信的。</p>
</li>
<li><p>公钥加密计算量太大，如何减少耗用的时间？</p>
<p>采用<strong>混合加密</strong>。每一次对话，客户端和服务器端都生成一个”<strong>对话密钥</strong>“，用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p>
</li>
</ol>
<p>因此，SSL/TLS协议的基本过程是这样的：</p>
<ul>
<li><p>客户端向服务器端索要并验证公钥；</p>
</li>
<li><p>双方协商生成”对话密钥”；</p>
</li>
<li><p>双方采用”对话密钥”进行加密通信；</p>
</li>
</ul>
<p>上面过程的前两步，又称为”握手阶段”。</p>
<h3 id="SSL-TSL握手"><a href="#SSL-TSL握手" class="headerlink" title="SSL/TSL握手"></a>SSL/TSL握手</h3><p>基于RSA加密的握手过程，也是基础的SSL/TSL握手过程。</p>
<p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记2.png?raw=true" srcset="/img/loading.gif" lazyload alt=""></p>
<p><strong>1. 客户端发出请求（ClientHello）</strong></p>
<p>客户端向服务器发出加密通信的请求，称为ClientHello请求，客户端主要向服务器提供以下信息：</p>
<p class="note note-secondary">
  （1）支持的协议版本，比如TLS 1.0版。
  <br>
  （2）一个客户端生成的随机数Client random，稍后用于生成"对话密钥"。
  <br>
  （3）支持的加密方法，比如RSA公钥加密。
  <br>
  （4）支持的压缩方法。
</p>

<p><strong>2. 服务器回应（SeverHello）</strong></p>
<p>服务器的回应包含以下内容：</p>
<p class="note note-secondary">
  （1）确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
  <br>
  （2）一个服务器生成的随机数Server random，稍后用于生成"对话密钥"。
  <br>
  （3）确认使用的加密方法，比如RSA公钥加密。
  <br>
  （4）服务器证书。
</p>

<p><strong>3. 客户端回应</strong></p>
<p>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。</p>
<p>如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。</p>
<p class="note note-secondary">
  （1）一个随机数。该随机数用服务器公钥加密，防止被窃听。
  <br>
  （2）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
  <br>
  （3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。
</p>

<p> 此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。</p>
<p>上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。</p>
<p>值得注意的是，该过程之前的阶段均为明文传输；而pre-master key使用服务器公钥加密，之后客户端与服务器端均生成会话密钥，数据传输均为加密传输。</p>
<p><strong>4. 服务器的最后回应</strong></p>
<p>服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。</p>
<p class="note note-secondary">
  （1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
  <br>
  （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。
</p>

<p>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。</p>
<p>使用 RSA密钥协商算法的最大问题是不支持前向保密。整个握手阶段都不加密（也没法加密），都是明文的。如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。所以一旦服务端的私钥泄漏 了，过去被第三方截获的所有 TLS 通讯密文都会被破解。所以目前使用较多的为<strong>ECDHE加密法</strong>。</p>
<h3 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h3><p><strong>离散对数</strong></p>
<p>假定 a, p 均是素数，下面两个集合相等，证明过程请参考 <a target="_blank" rel="noopener" href="http://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0133354695">Cryptography and Network Security</a> 第八章：</p>
<div class="code-wrapper"><pre><code class="hljs no">&#123; a^1 mod p, a^2 mod p, ..., a^(p-1) mod p &#125; = &#123;1, 2, ... , p-1 &#125;   &#123;&#125; 表示集合</code></pre></div>
<p>上述式子可概括成以下三点，对于 1 &lt;= x,y &lt;= p - 1，有：</p>
<ul>
<li>a^x mod p 一定属于 {1, 2, …, p -1 }</li>
<li>如果 x != y，则 a^x mod p != a^y mod p</li>
<li>对于 1 &lt;= b &lt;= p - 1，一定存在唯一的 1 &lt;= x &lt;= p-1，使得 b = a^x mod p</li>
</ul>
<p>第三点在求解上有这么一个特点：已知 x 求 b 非常容易，已知 b 求 x 非常困难，特别当 p 很大时，求解的复杂度非常高，所以它又被称为离散对数问题 (<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Discrete_logarithm">Discrete logarithm</a>)，它是 DH 算法能够安全交换密钥的基础</p>
<p><strong>求模公式</strong></p>
<p>假设 q 为素数，对于正整数 a,x,y，有：</p>
<div class="code-wrapper"><pre><code class="hljs no">(a^x mod p)^y mod p = a^(xy) mod p</code></pre></div>
<p>证明如下：</p>
<div class="code-wrapper"><pre><code class="hljs no">令 a^x = mp + n， 其中 m, n 为自然数， 0 &lt;= n &lt; p，则有
C = (a^x mod p)^y mod p
  = ((mp + n) mod p)^y mod p
  = n^y mod p
  = (mp +n)^y mod p
  = a^(xy) mod p</code></pre></div>
<p><strong>Deffie-Hellman 算法</strong></p>
<ol>
<li>首先 A, B 共同选取 p 和 a 两个素数，p 和 a 均公开；</li>
<li>之后 A 选择一个自然数 Xa &lt; p，计算出 Ya = a^Xa mod p，Xa 保密，Ya 公开；</li>
<li>同理，B 选择 Xb &lt; p 并计算出 Yb = a^Xb mod p，其中 Xb 保密，Yb 公开；</li>
<li>A 用 Yb 和 Xa 计算出密钥 K = Yb^Xa mod p，而 B 用 Ya 和 Xb 计算密钥 K = Ya^Xb mod p。</li>
</ol>
<p>流程如下：</p>
<div class="code-wrapper"><pre><code class="hljs no">+-------------------------------------------------------------------+
|                    Global Pulic Elements                          |
|                                                                   |
|       p                               prime number                |
|       a                               prime number, a &lt; p         |
+-------------------------------------------------------------------+
+-------------------------------------------------------------------+
|                    User A Key Generation                          |
|                                                                   |
|       Select private Xa               Xa &lt; p                      |
|       Calculate public Ya             Ya = a^Xa mod p             |
+-------------------------------------------------------------------+
+-------------------------------------------------------------------+
|                    User B Key Generation                          |
|                                                                   |
|       Select private Xb               Xb &lt; p                      |
|       Calculate public Yb             Yb = a^Xb mod p             |
+-------------------------------------------------------------------+
+-------------------------------------------------------------------+
|               Calculation of Secret Key by User A                 |
|                                                                   |
|       Secret Key K                    K = Yb^Xa mod p             |
+-------------------------------------------------------------------+
+-------------------------------------------------------------------+
|               Calculation of Secret Key by User B                 |
|                                                                   |
|       Secret Key K                    K = Ya^Xb mod p             |
+-------------------------------------------------------------------+</code></pre></div>
<p>下面证明，A 和 B 计算出来的密钥 K 相同。</p>
<div class="code-wrapper"><pre><code class="hljs no">K = Yb^Xa mod p
  = (a^Xb mod p)^Xa mod p
  = a^(Xa * Xb) mod p          根据上述求模公式
  = (a^Xa mod p)^Xb mod p
  = Ya^Xb mod p</code></pre></div>
<p>上面一共出现了 a, p, Xa, Ya, Xb, Yb, K 共 7 个数，其中：</p>
<ul>
<li>公开的数：a, p, Ya, Yb</li>
<li>非公开数：Xa, Xb, K</li>
</ul>
<p>通常情况下，a 一般为 2 或 5，而 p 的取值非常大，至少几百位，Xa 和 Xb 的取值也非常大，其复杂度至少为 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pollard&#39;s_rho_algorithm_for_logarithms">O(p^0.5)</a>。对于攻击者来说，已知 Ya，Xa 的求解非常困难，同理 Xb 的求解也很困难，所以攻击者难以求出 K，所以 DH 能够保证通信双方在<strong>透明</strong>的信道中安全的交换密钥。</p>
<p>DH 算法主要实现方法为<strong>DHE 算法</strong>，DHE 算法让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，E 全称是 ephemeral（临时性的）。这样就保证了 <strong>前向安全</strong>，即使曾经的通信过程被破解，不会影响现在的通信的安全性。</p>
<h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">阮一峰.RSA算法原理（一）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">阮一峰.SSL/TLS协议运行机制的概述</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">阮一峰.图解SSL/TLS协议</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6895624327896432654#heading-9">洛禹Keith.TLS 详解握手流程</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A">小林coding.图解 HTTP 常见的面试题</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">阮一峰.数字签名是什么</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html">阮一峰.密码学笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000024523772">编程指北.加密、数字签名和数字证书</a></p>
<p><a target="_blank" rel="noopener" href="http://wsfdl.com/algorithm/2016/02/04/理解Diffie-Hellman密钥交换算法.html">koala bear.理解 Deffie-Hellman 密钥交换算法</a></p>
<h1 id="TCP-篇"><a href="#TCP-篇" class="headerlink" title="TCP 篇"></a>TCP 篇</h1><p>TCP是<code>面向连接</code>的、<code>可靠</code>的、<code>基于字节流</code>的传输层通信协议。</p>
<h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h2><p>在介绍三次握手，四次挥手的过程之前，需要了解TCP头部的一些知识</p>
<p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记4.png?raw=true" srcset="/img/loading.gif" lazyload alt=""></p>
<ul>
<li><code>源端口</code>和目的端口：确定主机中的进程；</li>
<li>序号(seq)：报文段中的的第一个数据字节在数据流中的序号，主要用来解决网络报乱序的问题；</li>
<li>确认号(ack_seq)：所期望收到的下一个数据包的序号；</li>
<li>ACK：1有效，表示已经收到数据包</li>
<li>RST：1有效，连接复位请求</li>
<li>SYN：1有效，表示申请与接收方建立连接</li>
<li>FIN：1有效，表示申请与接收方断开连接</li>
</ul>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><blockquote>
<p>在Google Groups的<a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/pongba">TopLanguage</a>中看到一帖讨论TCP“三次握手”觉得很有意思。贴主提出“<a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!topic/pongba/kF6O7-MFxM0/discussion">TCP建立连接为什么是三次握手？</a>”的问题，在众多回复中，有<a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ">一条回复</a>写道：“这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”。</p>
</blockquote>
<p>网络中A与B要建立TCP连接，可以分为以下四步：</p>
<div class="code-wrapper"><pre><code class="hljs no">（1）A请求向B发送消息
（2）B向A表示同意
（3）B请求向A发送消息
（4）A向B表示同意</code></pre></div>
<p>可以发现，由于(2)(3)过程均为B向A发送消息，所以合为一次握手，实际上TCP建立连接只需要三次握手即可。</p>
<p>接下来介绍三次握手的具体过程</p>
<p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记5.png?raw=true" srcset="/img/loading.gif" lazyload alt=""></p>
<p class="note note-secondary">
  （1）A发送SYN=1，seq初始化为随机值X的连接请求报文段，之后进入SYN_SEND状态；
  <br>
  （2）收到连接请求前，B可以认为处于LISTEN阶段；收到连接请求后，B向A发送一个响应+请求报文段，置ACK=1，SYN=1，ack_seq=X+1，seq初始化为随机值Y，B进入SYN_RCVD状态；
  <br>
  （3）A响应B的连接请求，向B发送一个ACK=1的报文段，置seq=X+第一次握手报文长度1，ack_seq=Y，之后A进入ESTABLISHED状态；
  <br>
  （4）B收到A响应后同样进入ESTABLISHED状态，连接建立完成。
</p>

<h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="https://github.com/HerloConnell/BlogPicture/blob/CS-basics/图解计算机网络笔记6.png?raw=true" srcset="/img/loading.gif" lazyload alt=""></p>
<p>挥手过程，A与B断开连接之后，B可能还会有需要发个A的数据，不能立刻断开连接，需要有一个CLOSE_WAIT的过程，不能合为三次。</p>
<p class="note note-secondary">
  （1）A将FIN置为1，ACK置为1，seq设置为X=上一次对方传送过来的ack_seq，ack_seq设置为Y=为上一次对方传过来的seq+1。将数据发送至B，然后A进入FIN_WAIT_1状态；
  <br>
  （2）B收到了A发送的FIN报文段，向A回复，将ACK置为1，seq设置为Y，ack_seq设置为X+1。然后B进入CLOSE_WAIT状态，A收到B的回复后，进入FIN_WAIT_2状态；
  <br>
  （3）B再次向A发送报文，FIN置为1，ACK置为1，seq设置为Y，ack_seq设置为X+1，然后B进入LAST_ACK状态，A收到B的报文后，进入TIME_WAIT状态；
  <br>
  （4）A收到B发送的FIN报文段，向B回复，ACK置为1，seq设置为X+1，ack_seq设置为Y+1。然后A进入TIME_WAIT状态，B在收到报文后进入CLOSED状态。A在发送完报文等待了2MSL时间后进入CLOSED状态。
</p>

<p><strong>为什么 TIME_WAIT 状态要等待 2MSL 之后才关闭连接</strong></p>
<ul>
<li>2MSL表示两个MSL的时长，MSL全称为Maximum Segment Life，表示TCP Segment 生存时间的限制。</li>
<li>为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST_ACK状态的B收不到对自己已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段。而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后A和B都正常进入到CLOSED状态。如果A在TIME_WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而也不会在发送一次确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。</li>
<li>使下一个新的连接中不会出现这种旧的连接请求报文段。A在发送完最后一个ACK报文段后，在经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。</li>
</ul>
<h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://blog.jiar.me/2017/08/11/TCP三次握手简介/">Jiar.TCP三次握手简介</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.jiar.me/2017/08/24/TCP四次挥手简介/">Jiar.TCP四次挥手简介</a></p>
<h1 id="IP篇"><a href="#IP篇" class="headerlink" title="IP篇"></a>IP篇</h1><h1 id="网络安全篇"><a href="#网络安全篇" class="headerlink" title="网络安全篇"></a>网络安全篇</h1><h2 id="安全攻击分类"><a href="#安全攻击分类" class="headerlink" title="安全攻击分类"></a>安全攻击分类</h2><p><span class="label label-primary">被动攻击</span>：攻击者窃听监听数据传输，从而获取到传输的数据信息。主要有：消息内容泄露攻击和流量分析攻击。由于并没有修改数据，这种攻击是很难被检测到的。</p>
<p><span class="label label-primary">主动攻击</span>：攻击者修改传输的数据流或者故意添加错误的数据流，如假冒用户身份从而得到一些权限，进行权限攻击，除此之外，还有重放、改写和拒绝服务等。</p>
<h2 id="参考资料-3"><a href="#参考资料-3" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/detail/networks-interview-highlights/">Leetcode.计算机网络面试突击</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/26/Mysql%20with%20Mosh/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Mysql-Code with Mosh 笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/06/%E9%9D%A2%E7%BB%8F/">
                        <span class="hidden-mobile">面经</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
